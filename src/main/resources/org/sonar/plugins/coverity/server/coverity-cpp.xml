<rules>
<rule>
<name>Arguments in wrong order</name>
<key>STATIC_C_SWAPPED_ARGUMENTS_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_SWAPPED_ARGUMENTS_none</configKey>
<description><![CDATA[ The arguments to a function call are provided in the wrong order.]]></description>
</rule>
<rule>
<name>Bad COM BSTR comparison</name>
<key>STATIC_C_COM.BSTR.BAD_COMPARE_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_COM.BSTR.BAD_COMPARE_none</configKey>
<description><![CDATA[ Comparison of two BSTRs for other than equality]]></description>
</rule>
<rule>
<name>COM BSTR inequality with non-BSTR</name>
<key>STATIC_C_COM.BSTR.NE_NON_BSTR_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_COM.BSTR.NE_NON_BSTR_none</configKey>
<description><![CDATA[ Comparison of BSTR to other than BSTR]]></description>
</rule>
<rule>
<name>Insecure chroot</name>
<key>STATIC_C_CHROOT_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CHROOT_generic</configKey>
<description><![CDATA[ A call to chroot followed by an operation that may escape from the chroot jail]]></description>
</rule>
<rule>
<name>Insecure chroot</name>
<key>STATIC_C_CHROOT_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CHROOT_none</configKey>
<description><![CDATA[ A call to chroot followed by an operation that may escape from the chroot jail]]></description>
</rule>
<rule>
<name>Lock assertion failure</name>
<key>STATIC_C_LOCK_lock_assert</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_LOCK_lock_assert</configKey>
<description><![CDATA[ A lock assertion fails because a lock is not held on a path where it is asserted]]></description>
</rule>
<rule>
<name>Not restoring ostream format</name>
<key>STATIC_C_STREAM_FORMAT_STATE_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_STREAM_FORMAT_STATE_none</configKey>
<description><![CDATA[ Not restoring the stream format state of an ostream]]></description>
</rule>
<rule>
<name>Printf arg count mismatch</name>
<key>STATIC_C_PW.TOO_FEW_PRINTF_ARGS_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.TOO_FEW_PRINTF_ARGS_generic</configKey>
<description><![CDATA[ The number of arguments to printf does not match the format string]]></description>
</rule>
<rule>
<name>Printf arg count mismatch</name>
<key>STATIC_C_PW.TOO_FEW_PRINTF_ARGS_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.TOO_FEW_PRINTF_ARGS_none</configKey>
<description><![CDATA[ The number of arguments to printf does not match the format string]]></description>
</rule>
<rule>
<name>Printf arg count mismatch</name>
<key>STATIC_C_PW.TOO_MANY_PRINTF_ARGS_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.TOO_MANY_PRINTF_ARGS_generic</configKey>
<description><![CDATA[ The number of arguments to printf does not match the format string]]></description>
</rule>
<rule>
<name>Printf arg count mismatch</name>
<key>STATIC_C_PW.TOO_MANY_PRINTF_ARGS_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.TOO_MANY_PRINTF_ARGS_none</configKey>
<description><![CDATA[ The number of arguments to printf does not match the format string]]></description>
</rule>
<rule>
<name>Printf arg type mismatch</name>
<key>STATIC_C_PW.PRINTF_ARG_MISMATCH_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.PRINTF_ARG_MISMATCH_generic</configKey>
<description><![CDATA[ A printf format string does not match the types of one of the arguments]]></description>
</rule>
<rule>
<name>Printf arg type mismatch</name>
<key>STATIC_C_PW.PRINTF_ARG_MISMATCH_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.PRINTF_ARG_MISMATCH_none</configKey>
<description><![CDATA[ A printf format string does not match the types of one of the arguments]]></description>
</rule>
<rule>
<name>Printf format string issue</name>
<key>STATIC_C_PW.BAD_PRINTF_FORMAT_STRING_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.BAD_PRINTF_FORMAT_STRING_generic</configKey>
<description><![CDATA[ A printf format string contains an unrecognized format specifier]]></description>
</rule>
<rule>
<name>Printf format string issue</name>
<key>STATIC_C_PW.BAD_PRINTF_FORMAT_STRING_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.BAD_PRINTF_FORMAT_STRING_none</configKey>
<description><![CDATA[ A printf format string contains an unrecognized format specifier]]></description>
</rule>
<rule>
<name>Stream format state error</name>
<key>STATIC_C_STREAM_FORMAT_STATE_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_STREAM_FORMAT_STATE_generic</configKey>
<description><![CDATA[ Not restoring the stream format state of an ostream or setf called with invalid format state]]></description>
</rule>
<rule>
<name>Symbian - several objects pushed</name>
<key>STATIC_C_SYMBIAN.CLEANUP_STACK_multiple_pushes</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_SYMBIAN.CLEANUP_STACK_multiple_pushes</configKey>
<description><![CDATA[ A function pushes more than one object onto the cleanup stack in at least one possible execution]]></description>
</rule>
<rule>
<name>Symbian - wrong object popped</name>
<key>STATIC_C_SYMBIAN.CLEANUP_STACK_bad_pop_arg</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_SYMBIAN.CLEANUP_STACK_bad_pop_arg</configKey>
<description><![CDATA[ The cleanup stack is not empty at the end of the function, or function pops elements incorrectly]]></description>
</rule>
<rule>
<name>Unknown mask in setf</name>
<key>STATIC_C_STREAM_FORMAT_STATE_suspicious_setf_mask</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_STREAM_FORMAT_STATE_suspicious_setf_mask</configKey>
<description><![CDATA[ setf (or a similar) was called, but the argument was not recognized as being composed of valid format state bits]]></description>
</rule>
<rule>
<name>Using invalid iterator</name>
<key>STATIC_C_INVALIDATE_ITERATOR_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_INVALIDATE_ITERATOR_generic</configKey>
<description><![CDATA[ An invalid or past-the-end iterator is being used]]></description>
</rule>
<rule>
<name>Using invalid iterator</name>
<key>STATIC_C_INVALIDATE_ITERATOR_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_INVALIDATE_ITERATOR_none</configKey>
<description><![CDATA[ An invalid or past-the-end iterator is being used]]></description>
</rule>
<rule>
<name>Recursion in included headers</name>
<key>STATIC_C_PW.INCLUDE_RECURSION_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_PW.INCLUDE_RECURSION_generic</configKey>
<description><![CDATA[ Recursion in included header files]]></description>
</rule>
<rule>
<name>Recursion in included headers</name>
<key>STATIC_C_PW.INCLUDE_RECURSION_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_PW.INCLUDE_RECURSION_none</configKey>
<description><![CDATA[ Recursion in included header files]]></description>
</rule>
<rule>
<name>Misuse of memcmp-style function</name>
<key>STATIC_C_BAD_COMPARE_comparator_misuse</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_BAD_COMPARE_comparator_misuse</configKey>
<description><![CDATA[ A memcmp-style function is used assuming that it returns -1, 0, or 1.]]></description>
</rule>
<rule>
<name>Double close</name>
<key>STATIC_C_USE_AFTER_FREE_double_close</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_USE_AFTER_FREE_double_close</configKey>
<description><![CDATA[ A resource handle or descriptor is closed more than once]]></description>
</rule>
<rule>
<name>Use after close</name>
<key>STATIC_C_USE_AFTER_FREE_use_after_close</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_USE_AFTER_FREE_use_after_close</configKey>
<description><![CDATA[ A resource handle or descriptor is used after being closed]]></description>
</rule>
<rule>
<name>Empty virtual destructor</name>
<key>STATIC_C_VIRTUAL_DTOR_empty_dtor</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_VIRTUAL_DTOR_empty_dtor</configKey>
<description><![CDATA[ The correct derived class destructor that happens to be empty is not invoked due to the absence of a virtual destructor in the base class]]></description>
</rule>
<rule>
<name>Incorrect deallocator used</name>
<key>STATIC_C_ALLOC_FREE_MISMATCH_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_ALLOC_FREE_MISMATCH_none</configKey>
<description><![CDATA[ A resource is freed using the wrong deallocator]]></description>
</rule>
<rule>
<name>Failed to override method</name>
<key>STATIC_C_BAD_OVERRIDE_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_BAD_OVERRIDE_generic</configKey>
<description><![CDATA[ Virtual function does not override parent method because of type signature mismatch, usually due to const]]></description>
</rule>
<rule>
<name>Failed to override method</name>
<key>STATIC_C_BAD_OVERRIDE_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_BAD_OVERRIDE_none</configKey>
<description><![CDATA[ Virtual function does not override parent method because of type signature mismatch, usually due to const]]></description>
</rule>
<rule>
<name>Unnecessary header file</name>
<key>STATIC_C_HFA_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_HFA_generic</configKey>
<description><![CDATA[ A header file was included but none of its contents were used in the rest of the source file]]></description>
</rule>
<rule>
<name>Unnecessary header file</name>
<key>STATIC_C_HFA_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_HFA_none</configKey>
<description><![CDATA[ A header file was included but none of its contents were used in the rest of the source file]]></description>
</rule>
<rule>
<name>Insecure file permissions</name>
<key>STATIC_C_OPEN_ARGS_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_OPEN_ARGS_generic</configKey>
<description><![CDATA[ The open system call may create a file, but no permissions are specified]]></description>
</rule>
<rule>
<name>Insecure file permissions</name>
<key>STATIC_C_OPEN_ARGS_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_OPEN_ARGS_none</configKey>
<description><![CDATA[ The open system call may create a file, but no permissions are specified]]></description>
</rule>
<rule>
<name>Missing varargs init or cleanup</name>
<key>STATIC_C_VARARGS_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_VARARGS_generic</configKey>
<description><![CDATA[ Incorrect usage of variable argument macros; use va_start or va_copy to begin processing and va_end to finish]]></description>
</rule>
<rule>
<name>Missing varargs init or cleanup</name>
<key>STATIC_C_VARARGS_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_VARARGS_none</configKey>
<description><![CDATA[ Incorrect usage of variable argument macros; use va_start or va_copy to begin processing and va_end to finish]]></description>
</rule>
<rule>
<name>Sizeof not portable</name>
<key>STATIC_C_SIZEOF_MISMATCH_sizeof_punning</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_SIZEOF_MISMATCH_sizeof_punning</configKey>
<description><![CDATA[ The sizeof operator is used on a wrong argument that incidentally has the same size]]></description>
</rule>
<rule>
<name>Symbian - missing L suffix</name>
<key>STATIC_C_SYMBIAN.NAMING_naming_L</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_SYMBIAN.NAMING_naming_L</configKey>
<description><![CDATA[ Violation of the Symbian naming convention: leaving functions should contain L in their suffix]]></description>
</rule>
<rule>
<name>Symbian - missing LC suffix</name>
<key>STATIC_C_SYMBIAN.NAMING_naming_LC</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_SYMBIAN.NAMING_naming_LC</configKey>
<description><![CDATA[ Violation of the Symbian naming convention: functions that push an element to the cleanup stack should contain LC in their suffix]]></description>
</rule>
<rule>
<name>Symbian - naming convention</name>
<key>STATIC_C_SYMBIAN.NAMING_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_SYMBIAN.NAMING_generic</configKey>
<description><![CDATA[ Violation of the Symbian naming convention]]></description>
</rule>
<rule>
<name>Symbian - naming convention</name>
<key>STATIC_C_SYMBIAN.NAMING_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_SYMBIAN.NAMING_none</configKey>
<description><![CDATA[ Violation of the Symbian naming convention]]></description>
</rule>
<rule>
<name>Unused pointer value</name>
<key>STATIC_C_UNUSED_VALUE_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_UNUSED_VALUE_generic</configKey>
<description><![CDATA[ Pointer returned from a function was never used]]></description>
</rule>
<rule>
<name>Unused pointer value</name>
<key>STATIC_C_UNUSED_VALUE_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_UNUSED_VALUE_none</configKey>
<description><![CDATA[ Pointer returned from a function was never used]]></description>
</rule>
<rule>
<name>Data race condition</name>
<key>STATIC_C_MISSING_LOCK_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISSING_LOCK_generic</configKey>
<description><![CDATA[ Thread shared data is accessed without holding an appropriate lock, possibly causing a race condition]]></description>
</rule>
<rule>
<name>Data race condition</name>
<key>STATIC_C_MISSING_LOCK_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISSING_LOCK_none</configKey>
<description><![CDATA[ Thread shared data is accessed without holding an appropriate lock, possibly causing a race condition]]></description>
</rule>
<rule>
<name>Value not atomically updated</name>
<key>STATIC_C_ATOMICITY_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_ATOMICITY_generic</configKey>
<description><![CDATA[ Non-atomic update of a concurrently shared value]]></description>
</rule>
<rule>
<name>Value not atomically updated</name>
<key>STATIC_C_ATOMICITY_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_ATOMICITY_none</configKey>
<description><![CDATA[ Non-atomic update of a concurrently shared value]]></description>
</rule>
<rule>
<name>Branch past initialization</name>
<key>STATIC_C_PW.BRANCH_PAST_INITIALIZATION_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.BRANCH_PAST_INITIALIZATION_generic</configKey>
<description><![CDATA[ A goto jumps past the initialization of a variable]]></description>
</rule>
<rule>
<name>Branch past initialization</name>
<key>STATIC_C_PW.BRANCH_PAST_INITIALIZATION_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.BRANCH_PAST_INITIALIZATION_none</configKey>
<description><![CDATA[ A goto jumps past the initialization of a variable]]></description>
</rule>
<rule>
<name>Dead case in switch</name>
<key>STATIC_C_DEADCODE_dead_case_in_switch</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_DEADCODE_dead_case_in_switch</configKey>
<description><![CDATA[ Switch never goes directly to this case]]></description>
</rule>
<rule>
<name>Dead default in switch</name>
<key>STATIC_C_DEADCODE_dead_default_in_switch</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_DEADCODE_dead_default_in_switch</configKey>
<description><![CDATA[ Default in switch statement is dead code]]></description>
</rule>
<rule>
<name>Invalid iterator comparison</name>
<key>STATIC_C_MISMATCHED_ITERATOR_mismatched_comparison</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISMATCHED_ITERATOR_mismatched_comparison</configKey>
<description><![CDATA[ Iterators that point to different containers are compared]]></description>
</rule>
<rule>
<name>Logically dead code</name>
<key>STATIC_C_DEADCODE_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_DEADCODE_generic</configKey>
<description><![CDATA[ Code can never be reached because of a logical contradiction]]></description>
</rule>
<rule>
<name>Logically dead code</name>
<key>STATIC_C_DEADCODE_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_DEADCODE_none</configKey>
<description><![CDATA[ Code can never be reached because of a logical contradiction]]></description>
</rule>
<rule>
<name>Missing break in switch</name>
<key>STATIC_C_MISSING_BREAK_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISSING_BREAK_generic</configKey>
<description><![CDATA[ Missing break statement between cases in switch statement]]></description>
</rule>
<rule>
<name>Missing break in switch</name>
<key>STATIC_C_MISSING_BREAK_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISSING_BREAK_none</configKey>
<description><![CDATA[ Missing break statement between cases in switch statement]]></description>
</rule>
<rule>
<name>Redundant test</name>
<key>STATIC_C_DEADCODE_redundant_test</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_DEADCODE_redundant_test</configKey>
<description><![CDATA[ Test always evaluates the same]]></description>
</rule>
<rule>
<name>Nesting level does not match indentation</name>
<key>STATIC_C_NESTING_INDENT_MISMATCH_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NESTING_INDENT_MISMATCH_none</configKey>
<description><![CDATA[ The indentation of this code suggests it is nested when it is not.]]></description>
</rule>
<rule>
<name>Stray semicolon</name>
<key>STATIC_C_STRAY_SEMICOLON_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_STRAY_SEMICOLON_generic</configKey>
<description><![CDATA[ A semicolon was erroneously inserted at a wrong point in the code, e.g. after an if, while, or for construct and before the block]]></description>
</rule>
<rule>
<name>Structurally dead code</name>
<key>STATIC_C_UNREACHABLE_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_UNREACHABLE_generic</configKey>
<description><![CDATA[ Code block is unreachable because of the syntactic structure of the code]]></description>
</rule>
<rule>
<name>Structurally dead code</name>
<key>STATIC_C_UNREACHABLE_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_UNREACHABLE_none</configKey>
<description><![CDATA[ Code block is unreachable because of the syntactic structure of the code]]></description>
</rule>
<rule>
<name>Unsigned compared against 0</name>
<key>STATIC_C_NO_EFFECT_unsigned_compare</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NO_EFFECT_unsigned_compare</configKey>
<description><![CDATA[ An unsigned value can never be less than 0]]></description>
</rule>
<rule>
<name>Argument cannot be negative</name>
<key>STATIC_C_NEGATIVE_RETURNS_critical_argument</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NEGATIVE_RETURNS_critical_argument</configKey>
<description><![CDATA[ Negative value used as  argument to a function expecting a positive value (for example, size of buffer or allocation)]]></description>
</rule>
<rule>
<name>Uncaught exception</name>
<key>STATIC_C_UNCAUGHT_EXCEPT_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_UNCAUGHT_EXCEPT_generic</configKey>
<description><![CDATA[ A C++ exception is thrown but never caught]]></description>
</rule>
<rule>
<name>Uncaught exception</name>
<key>STATIC_C_UNCAUGHT_EXCEPT_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_UNCAUGHT_EXCEPT_none</configKey>
<description><![CDATA[ A C++ exception is thrown but never caught]]></description>
</rule>
<rule>
<name>Unchecked return value</name>
<key>STATIC_C_CHECKED_RETURN_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CHECKED_RETURN_generic</configKey>
<description><![CDATA[ Value returned from a function is not checked for errors before being used]]></description>
</rule>
<rule>
<name>Unchecked return value</name>
<key>STATIC_C_CHECKED_RETURN_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CHECKED_RETURN_none</configKey>
<description><![CDATA[ Value returned from a function is not checked for errors before being used]]></description>
</rule>
<rule>
<name>Unchecked return value as arg</name>
<key>STATIC_C_CHECKED_RETURN_unchecked_arg</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CHECKED_RETURN_unchecked_arg</configKey>
<description><![CDATA[ Value returned from a function is not checked for errors, and passed directly to another function as an argument]]></description>
</rule>
<rule>
<name>Array compared against 0</name>
<key>STATIC_C_NO_EFFECT_array_null</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NO_EFFECT_array_null</configKey>
<description><![CDATA[ Array compared against NULL pointer]]></description>
</rule>
<rule>
<name>Assign instead of compare</name>
<key>STATIC_C_PW.ASSIGN_WHERE_COMPARE_MEANT_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.ASSIGN_WHERE_COMPARE_MEANT_generic</configKey>
<description><![CDATA[ An assignment (=) occurs where compare (==) is probably intended]]></description>
</rule>
<rule>
<name>Assign instead of compare</name>
<key>STATIC_C_PW.ASSIGN_WHERE_COMPARE_MEANT_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.ASSIGN_WHERE_COMPARE_MEANT_none</configKey>
<description><![CDATA[ An assignment (=) occurs where compare (==) is probably intended]]></description>
</rule>
<rule>
<name>Copy-paste error</name>
<key>STATIC_C_COPY_PASTE_ERROR_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_COPY_PASTE_ERROR_generic</configKey>
<description><![CDATA[ A copied piece of code is inconsistent with the original]]></description>
</rule>
<rule>
<name>Copy-paste error</name>
<key>STATIC_C_COPY_PASTE_ERROR_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_COPY_PASTE_ERROR_none</configKey>
<description><![CDATA[ A copied piece of code is inconsistent with the original]]></description>
</rule>
<rule>
<name>Expression with no effect</name>
<key>STATIC_C_NO_EFFECT_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NO_EFFECT_generic</configKey>
<description><![CDATA[ An expression with no side-effect or unintended effect indicates a possible logic flaw]]></description>
</rule>
<rule>
<name>Expression with no effect</name>
<key>STATIC_C_NO_EFFECT_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NO_EFFECT_none</configKey>
<description><![CDATA[ An expression with no side-effect or unintended effect indicates a possible logic flaw]]></description>
</rule>
<rule>
<name>Expression with no effect</name>
<key>STATIC_C_PW.EXPR_HAS_NO_EFFECT_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.EXPR_HAS_NO_EFFECT_generic</configKey>
<description><![CDATA[ An expression with no side-effect or unintended effect indicates a possible logic flaw]]></description>
</rule>
<rule>
<name>Expression with no effect</name>
<key>STATIC_C_PW.EXPR_HAS_NO_EFFECT_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.EXPR_HAS_NO_EFFECT_none</configKey>
<description><![CDATA[ An expression with no side-effect or unintended effect indicates a possible logic flaw]]></description>
</rule>
<rule>
<name>Extra sizeof expression</name>
<key>STATIC_C_SIZEOF_MISMATCH_extra_sizeof</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_SIZEOF_MISMATCH_extra_sizeof</configKey>
<description><![CDATA[ The sizeof operator is not required in the expression]]></description>
</rule>
<rule>
<name>Function address comparison</name>
<key>STATIC_C_BAD_COMPARE_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_BAD_COMPARE_generic</configKey>
<description><![CDATA[ Address of function compared to zero]]></description>
</rule>
<rule>
<name>Function address comparison</name>
<key>STATIC_C_BAD_COMPARE_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_BAD_COMPARE_none</configKey>
<description><![CDATA[ Address of function compared to zero]]></description>
</rule>
<rule>
<name>Function in assertion</name>
<key>STATIC_C_ASSERT_SIDE_EFFECT_side_effect_is_function</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_ASSERT_SIDE_EFFECT_side_effect_is_function</configKey>
<description><![CDATA[ Assertion contains a function call which may have a side effect]]></description>
</rule>
<rule>
<name>Incorrect pointer increment</name>
<key>STATIC_C_NO_EFFECT_no_effect_deref</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NO_EFFECT_no_effect_deref</configKey>
<description><![CDATA[ Increment (or decrement) of pointer value, not the value pointed-to]]></description>
</rule>
<rule>
<name>Incorrect sizeof expression</name>
<key>STATIC_C_BAD_SIZEOF_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_BAD_SIZEOF_generic</configKey>
<description><![CDATA[ The sizeof operator was applied to an unintended variable or expression, such as a pointer variable instead of its target]]></description>
</rule>
<rule>
<name>Incorrect sizeof expression</name>
<key>STATIC_C_BAD_SIZEOF_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_BAD_SIZEOF_none</configKey>
<description><![CDATA[ The sizeof operator was applied to an unintended variable or expression, such as a pointer variable instead of its target]]></description>
</rule>
<rule>
<name>Inequality comparison against NULL</name>
<key>STATIC_C_BAD_COMPARE_null_misuse</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_BAD_COMPARE_null_misuse</configKey>
<description><![CDATA[ Comparing a pointer against NULL using an operator such as < or >=.]]></description>
</rule>
<rule>
<name>Missing parentheses</name>
<key>STATIC_C_CONSTANT_EXPRESSION_RESULT_missing_parentheses</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_missing_parentheses</configKey>
<description><![CDATA[ Missing parentheses caused unintended operator precedence]]></description>
</rule>
<rule>
<name>Misused comma operator</name>
<key>STATIC_C_NO_EFFECT_extra_comma</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NO_EFFECT_extra_comma</configKey>
<description><![CDATA[ Comma operator has a left sub-expression with no side-effects]]></description>
</rule>
<rule>
<name>Misused sizeof</name>
<key>STATIC_C_SIZEOF_MISMATCH_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_SIZEOF_MISMATCH_generic</configKey>
<description><![CDATA[ The sizeof operator is used erroneously in an expression or is invoked on the wrong argument]]></description>
</rule>
<rule>
<name>Misused sizeof</name>
<key>STATIC_C_SIZEOF_MISMATCH_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_SIZEOF_MISMATCH_none</configKey>
<description><![CDATA[ The sizeof operator is used erroneously in an expression or is invoked on the wrong argument]]></description>
</rule>
<rule>
<name>Pointer comparison with string literal</name>
<key>STATIC_C_BAD_COMPARE_string_lit_comparison</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_BAD_COMPARE_string_lit_comparison</configKey>
<description><![CDATA[ Comparing against the address of a string literal.]]></description>
</rule>
<rule>
<name>Self assignment</name>
<key>STATIC_C_NO_EFFECT_self_assign</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NO_EFFECT_self_assign</configKey>
<description><![CDATA[ Assignment of a variable or expression to itself has no effect]]></description>
</rule>
<rule>
<name>Side effect in assertion</name>
<key>STATIC_C_ASSERT_SIDE_EFFECT_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_ASSERT_SIDE_EFFECT_generic</configKey>
<description><![CDATA[ Assertion contains an operation with a side effect]]></description>
</rule>
<rule>
<name>Side effect in assertion</name>
<key>STATIC_C_ASSERT_SIDE_EFFECT_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_ASSERT_SIDE_EFFECT_none</configKey>
<description><![CDATA[ Assertion contains an operation with a side effect]]></description>
</rule>
<rule>
<name>Sizeof pointer expression</name>
<key>STATIC_C_BAD_SIZEOF_sizeof_ptr_expr</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_BAD_SIZEOF_sizeof_ptr_expr</configKey>
<description><![CDATA[ The sizeof operator was applied to a pointer expression, which may not be intended]]></description>
</rule>
<rule>
<name>Switch test assignment</name>
<key>STATIC_C_NO_EFFECT_bool_switch</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NO_EFFECT_bool_switch</configKey>
<description><![CDATA[ A boolean test within a switch condition is likely an intended assignment]]></description>
</rule>
<rule>
<name>Test should be assignment</name>
<key>STATIC_C_NO_EFFECT_no_effect_test</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NO_EFFECT_no_effect_test</configKey>
<description><![CDATA[ A test that is an isolated statement with no effect is likely an intended assignment]]></description>
</rule>
<rule>
<name>Wrong sizeof argument</name>
<key>STATIC_C_SIZEOF_MISMATCH_wrong_sizeof</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_SIZEOF_MISMATCH_wrong_sizeof</configKey>
<description><![CDATA[ The sizeof operator is invoked on the wrong argument]]></description>
</rule>
<rule>
<name>Format string vulnerability</name>
<key>STATIC_C_TAINTED_STRING_format_string</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_TAINTED_STRING_format_string</configKey>
<description><![CDATA[ An unscrutinized value from an untrusted source used to construct a format string]]></description>
</rule>
<rule>
<name>Integer overflow</name>
<key>STATIC_C_INTEGER_OVERFLOW_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_INTEGER_OVERFLOW_generic</configKey>
<description><![CDATA[ An integer overflow occurs, with the overflowed value used in a sensitive operation]]></description>
</rule>
<rule>
<name>Unchecked return value from library</name>
<key>STATIC_C_CHECKED_RETURN_library_function</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CHECKED_RETURN_library_function</configKey>
<description><![CDATA[ Value returned from a library function is not checked for errors before being used.  This value may indicate an error condition.]]></description>
</rule>
<rule>
<name>Unchecked return value from user code</name>
<key>STATIC_C_CHECKED_RETURN_user_required</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CHECKED_RETURN_user_required</configKey>
<description><![CDATA[ Value returned from a program function is not checked before being used.  It has been marked that its return value should always be checked.]]></description>
</rule>
<rule>
<name>Integer overflow</name>
<key>STATIC_C_INTEGER_OVERFLOW_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_INTEGER_OVERFLOW_none</configKey>
<description><![CDATA[ An integer overflow occurs, with the overflowed value used in a sensitive operation]]></description>
</rule>
<rule>
<name>Integer overflowed argument</name>
<key>STATIC_C_INTEGER_OVERFLOW_critical_argument</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_INTEGER_OVERFLOW_critical_argument</configKey>
<description><![CDATA[ An integer overflow occurs, with the overflowed value used as an argument to a function]]></description>
</rule>
<rule>
<name>Overflowed return value</name>
<key>STATIC_C_INTEGER_OVERFLOW_return_value_error</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_INTEGER_OVERFLOW_return_value_error</configKey>
<description><![CDATA[ An integer overflow occurs, with the overflowed value used as the return value of the function]]></description>
</rule>
<rule>
<name>Untrusted array index read</name>
<key>STATIC_C_TAINTED_SCALAR_array_index_read</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_TAINTED_SCALAR_array_index_read</configKey>
<description><![CDATA[ Read from array at index computed using an unscrutinized value from an untrusted source]]></description>
</rule>
<rule>
<name>Untrusted array index write</name>
<key>STATIC_C_TAINTED_SCALAR_array_index_write</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_TAINTED_SCALAR_array_index_write</configKey>
<description><![CDATA[ Write to array at index computed using an unscrutinized value from an untrusted source]]></description>
</rule>
<rule>
<name>Untrusted loop bound</name>
<key>STATIC_C_TAINTED_SCALAR_loop_bound</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_TAINTED_SCALAR_loop_bound</configKey>
<description><![CDATA[ An unscrutinzed value from an untrusted source used as a loop upper bound]]></description>
</rule>
<rule>
<name>Untrusted pointer read</name>
<key>STATIC_C_TAINTED_SCALAR_pointer_deref_read</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_TAINTED_SCALAR_pointer_deref_read</configKey>
<description><![CDATA[ Reads target of a pointer computed using an unscrutinized value from an untrusted source]]></description>
</rule>
<rule>
<name>Untrusted pointer write</name>
<key>STATIC_C_TAINTED_SCALAR_pointer_deref_write</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_TAINTED_SCALAR_pointer_deref_write</configKey>
<description><![CDATA[ Write to target of pointer computed using an unscrutinized value from an untrusted source]]></description>
</rule>
<rule>
<name>Untrusted value as argument</name>
<key>STATIC_C_TAINTED_SCALAR_critical_argument</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_TAINTED_SCALAR_critical_argument</configKey>
<description><![CDATA[ An unscrutinized value from an untrusted source used as argument to a function (for example, a buffer size)]]></description>
</rule>
<rule>
<name>Use of untrusted scalar value</name>
<key>STATIC_C_TAINTED_SCALAR_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_TAINTED_SCALAR_none</configKey>
<description><![CDATA[ An unscrutinized value from an untrusted source used in a trusted context]]></description>
</rule>
<rule>
<name>Use of untrusted string value</name>
<key>STATIC_C_TAINTED_STRING_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_TAINTED_STRING_generic</configKey>
<description><![CDATA[ An unscrutinized string from an untrusted source used in a trusted context]]></description>
</rule>
<rule>
<name>Use of untrusted string value</name>
<key>STATIC_C_TAINTED_STRING_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_TAINTED_STRING_none</configKey>
<description><![CDATA[ An unscrutinized string from an untrusted source used in a trusted context]]></description>
</rule>
<rule>
<name>Use of untrusted value</name>
<key>STATIC_C_TAINTED_SCALAR_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_TAINTED_SCALAR_generic</configKey>
<description><![CDATA[ An unscrutinized value from an untrusted source used in a trusted context]]></description>
</rule>
<rule>
<name>Evaluation order violation</name>
<key>STATIC_C_EVALUATION_ORDER_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_EVALUATION_ORDER_generic</configKey>
<description><![CDATA[ Statement contains multiple side-effects on the same value with an undefined evaluation order]]></description>
</rule>
<rule>
<name>Evaluation order violation</name>
<key>STATIC_C_EVALUATION_ORDER_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_EVALUATION_ORDER_none</configKey>
<description><![CDATA[ Statement contains multiple side-effects on the same value with an undefined evaluation order]]></description>
</rule>
<rule>
<name>Mixing enum types</name>
<key>STATIC_C_MIXED_ENUMS_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MIXED_ENUMS_generic</configKey>
<description><![CDATA[ An enum-typed expression is mixed with a different enum type]]></description>
</rule>
<rule>
<name>Inferred misuse of enum</name>
<key>STATIC_C_MIXED_ENUMS_inferred</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MIXED_ENUMS_inferred</configKey>
<description><![CDATA[ An integer expression which was inferred to have an enum type is mixed with a different enum type]]></description>
</rule>
<rule>
<name>Bitwise-and with zero</name>
<key>STATIC_C_CONSTANT_EXPRESSION_RESULT_bit_and_with_zero</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_bit_and_with_zero</configKey>
<description><![CDATA[ Bitwise-and ('&amp;') operation applied to zero always produces zero]]></description>
</rule>
<rule>
<name>Constant expression result</name>
<key>STATIC_C_CONSTANT_EXPRESSION_RESULT_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_generic</configKey>
<description><![CDATA[ An operation with non-constant operands that computes a result with constant value]]></description>
</rule>
<rule>
<name>Constant expression result</name>
<key>STATIC_C_CONSTANT_EXPRESSION_RESULT_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_none</configKey>
<description><![CDATA[ An operation with non-constant operands that computes a result with constant value]]></description>
</rule>
<rule>
<name>Divide by zero</name>
<key>STATIC_C_PW.DIVIDE_BY_ZERO_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.DIVIDE_BY_ZERO_generic</configKey>
<description><![CDATA[ Divide by zero]]></description>
</rule>
<rule>
<name>Divide by zero</name>
<key>STATIC_C_PW.DIVIDE_BY_ZERO_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.DIVIDE_BY_ZERO_none</configKey>
<description><![CDATA[ Divide by zero]]></description>
</rule>
<rule>
<name>Enum compared against 0</name>
<key>STATIC_C_NO_EFFECT_unsigned_enums</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NO_EFFECT_unsigned_enums</configKey>
<description><![CDATA[ An enumeration value is usually not less than 0]]></description>
</rule>
<rule>
<name>Extra high-order bits</name>
<key>STATIC_C_CONSTANT_EXPRESSION_RESULT_extra_high_bits</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_extra_high_bits</configKey>
<description><![CDATA[ In an operation, the high-order bits of wider operand do not affect the narrower operand]]></description>
</rule>
<rule>
<name>Implicit conversion</name>
<key>STATIC_C_MISRA_CAST_integer_to_float_conversion</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_integer_to_float_conversion</configKey>
<description><![CDATA[ Implicitly converting complex expression with integer type to floating type (MISRA 2004 Rule 10.1)]]></description>
</rule>
<rule>
<name>Implicit floating conversion</name>
<key>STATIC_C_MISRA_CAST_float_complex_conversion</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_float_complex_conversion</configKey>
<description><![CDATA[ Implicitly converting complex expression from float to double (MISRA 2004 Rule 10.2)]]></description>
</rule>
<rule>
<name>Implicit floating conversion</name>
<key>STATIC_C_MISRA_CAST_float_narrowing_conversion</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_float_narrowing_conversion</configKey>
<description><![CDATA[ Implicitly converting a double expression to narrower float type may lose precision (MISRA 2004 Rule 10.2)]]></description>
</rule>
<rule>
<name>Implicit floating conversion</name>
<key>STATIC_C_MISRA_CAST_float_non_constant_arg_conversion</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_float_non_constant_arg_conversion</configKey>
<description><![CDATA[ Implicit conversion from float to double in a function argument (MISRA 2004 Rule 10.2)]]></description>
</rule>
<rule>
<name>Implicit floating conversion</name>
<key>STATIC_C_MISRA_CAST_float_non_constant_rtn_conversion</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_float_non_constant_rtn_conversion</configKey>
<description><![CDATA[ Implicit conversion from float to double in a return expression (MISRA 2004 Rule 10.2)]]></description>
</rule>
<rule>
<name>Implicit floating conversion</name>
<key>STATIC_C_MISRA_CAST_float_to_integer_conversion</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_float_to_integer_conversion</configKey>
<description><![CDATA[ Implicit conversion from float to 16-bit integer type (MISRA 2004 Rule 10.2)]]></description>
</rule>
<rule>
<name>Implicit integer conversion</name>
<key>STATIC_C_MISRA_CAST_integer_complex_conversion</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_integer_complex_conversion</configKey>
<description><![CDATA[ Implicitly converting the type of a complex expression (MISRA 2004 Rule 10.1)]]></description>
</rule>
<rule>
<name>Implicit integer conversion</name>
<key>STATIC_C_MISRA_CAST_integer_narrowing_conversion</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_integer_narrowing_conversion</configKey>
<description><![CDATA[ Implicitly converting an integer expression to a narrower integer type may truncate value (MISRA 2004 Rule 10.1)]]></description>
</rule>
<rule>
<name>Implicit integer conversion</name>
<key>STATIC_C_MISRA_CAST_integer_non_constant_arg_conversion</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_integer_non_constant_arg_conversion</configKey>
<description><![CDATA[ Implicitly converting the integer type of a non-constant function argument expression (MISRA 2004 Rule 10.1)]]></description>
</rule>
<rule>
<name>Implicit integer conversion</name>
<key>STATIC_C_MISRA_CAST_integer_non_constant_rtn_conversion</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_integer_non_constant_rtn_conversion</configKey>
<description><![CDATA[ Implicitly converting the integer type of a non-constant return expression (MISRA 2004 Rule 10.1)]]></description>
</rule>
<rule>
<name>Implicit integer conversion</name>
<key>STATIC_C_MISRA_CAST_integer_signedness_changing_conversion</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_integer_signedness_changing_conversion</configKey>
<description><![CDATA[ Implicitly converting the signedness of an integer value (MISRA 2004 Rule 10.1)]]></description>
</rule>
<rule>
<name>Improper use of negative value</name>
<key>STATIC_C_NEGATIVE_RETURNS_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NEGATIVE_RETURNS_generic</configKey>
<description><![CDATA[ Negative value returned from function is not being checked before being used improperly]]></description>
</rule>
<rule>
<name>Improper use of negative value</name>
<key>STATIC_C_NEGATIVE_RETURNS_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NEGATIVE_RETURNS_none</configKey>
<description><![CDATA[ Negative value can be returned from function is not being checked before being used improperly]]></description>
</rule>
<rule>
<name>Improper use of negative value</name>
<key>STATIC_C_REVERSE_NEGATIVE_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_REVERSE_NEGATIVE_generic</configKey>
<description><![CDATA[ Negative value used incorrectly where positive value is expected]]></description>
</rule>
<rule>
<name>Improper use of negative value</name>
<key>STATIC_C_REVERSE_NEGATIVE_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_REVERSE_NEGATIVE_none</configKey>
<description><![CDATA[ Negative value used incorrectly where positive value is expected]]></description>
</rule>
<rule>
<name>Incompatible cast</name>
<key>STATIC_C_INCOMPATIBLE_CAST_float_vs_integral</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_INCOMPATIBLE_CAST_float_vs_integral</configKey>
<description><![CDATA[ Cast between floating-point and integral pointers]]></description>
</rule>
<rule>
<name>Incompatible pointer cast</name>
<key>STATIC_C_INCOMPATIBLE_CAST_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_INCOMPATIBLE_CAST_generic</configKey>
<description><![CDATA[ Cast between incompatible pointer types]]></description>
</rule>
<rule>
<name>Incompatible pointer cast</name>
<key>STATIC_C_INCOMPATIBLE_CAST_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_INCOMPATIBLE_CAST_none</configKey>
<description><![CDATA[ Cast between incompatible pointer types]]></description>
</rule>
<rule>
<name>Integer overflow warning</name>
<key>STATIC_C_PW.INTEGER_OVERFLOW_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.INTEGER_OVERFLOW_generic</configKey>
<description><![CDATA[ An integer overflow occurs at compile time when parsing this expression]]></description>
</rule>
<rule>
<name>Integer overflow warning</name>
<key>STATIC_C_PW.INTEGER_OVERFLOW_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.INTEGER_OVERFLOW_none</configKey>
<description><![CDATA[ An integer overflow occurs at compile time when parsing this expression]]></description>
</rule>
<rule>
<name>Integer overflow warning</name>
<key>STATIC_C_PW.INTEGER_TOO_LARGE_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.INTEGER_TOO_LARGE_generic</configKey>
<description><![CDATA[ An integer overflow occurs at compile time when parsing this expression]]></description>
</rule>
<rule>
<name>Integer overflow warning</name>
<key>STATIC_C_PW.INTEGER_TOO_LARGE_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.INTEGER_TOO_LARGE_none</configKey>
<description><![CDATA[ An integer overflow occurs at compile time when parsing this expression]]></description>
</rule>
<rule>
<name>Integer overflow warning</name>
<key>STATIC_C_PW.SHIFT_COUNT_TOO_LARGE_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.SHIFT_COUNT_TOO_LARGE_generic</configKey>
<description><![CDATA[ An integer overflow occurs at compile time when parsing this expression]]></description>
</rule>
<rule>
<name>Integer overflow warning</name>
<key>STATIC_C_PW.SHIFT_COUNT_TOO_LARGE_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.SHIFT_COUNT_TOO_LARGE_none</configKey>
<description><![CDATA[ An integer overflow occurs at compile time when parsing this expression]]></description>
</rule>
<rule>
<name>Logical vs. bitwise operator</name>
<key>STATIC_C_CONSTANT_EXPRESSION_RESULT_logical_vs_bitwise</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_logical_vs_bitwise</configKey>
<description><![CDATA[ Logical operator used in place of bitwise operator or vice versa]]></description>
</rule>
<rule>
<name>Lossy integer to pointer</name>
<key>STATIC_C_PW.BAD_CAST_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.BAD_CAST_generic</configKey>
<description><![CDATA[ A cast from an integer to a pointer of narrower precision]]></description>
</rule>
<rule>
<name>Lossy integer to pointer</name>
<key>STATIC_C_PW.BAD_CAST_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.BAD_CAST_none</configKey>
<description><![CDATA[ A cast from an integer to a pointer of narrower precision]]></description>
</rule>
<rule>
<name>Lossy integer to pointer</name>
<key>STATIC_C_PW.CONVERSION_TO_POINTER_LOSES_BITS_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.CONVERSION_TO_POINTER_LOSES_BITS_generic</configKey>
<description><![CDATA[ A cast from an integer to a pointer of narrower precision]]></description>
</rule>
<rule>
<name>Lossy integer to pointer</name>
<key>STATIC_C_PW.CONVERSION_TO_POINTER_LOSES_BITS_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.CONVERSION_TO_POINTER_LOSES_BITS_none</configKey>
<description><![CDATA[ A cast from an integer to a pointer of narrower precision]]></description>
</rule>
<rule>
<name>Macro compares unsigned to 0</name>
<key>STATIC_C_NO_EFFECT_unsigned_compare_macros</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NO_EFFECT_unsigned_compare_macros</configKey>
<description><![CDATA[ An unsigned value can never be less than 0]]></description>
</rule>
<rule>
<name>Misra violating cast</name>
<key>STATIC_C_MISRA_CAST_bitwise_op_bad_cast</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_bitwise_op_bad_cast</configKey>
<description><![CDATA[ Bitwise operator << applies to operand with underlying type unsigned short is cast to int (MISRA 2004 Rule 10.5)]]></description>
</rule>
<rule>
<name>Misra violating cast</name>
<key>STATIC_C_MISRA_CAST_bitwise_op_no_cast</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_bitwise_op_no_cast</configKey>
<description><![CDATA[ Bitwise operator << applies to operand with underlying type unsigned short is not being immediately cast to that type (MISRA 2004 Rule 10.5)]]></description>
</rule>
<rule>
<name>Misra violating cast</name>
<key>STATIC_C_MISRA_CAST_float_to_integer_cast</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_float_to_integer_cast</configKey>
<description><![CDATA[ Complex expression cast from 64-bit float to 16-bit int (MISRA 2004 Rule 10.4)]]></description>
</rule>
<rule>
<name>Misra violating cast</name>
<key>STATIC_C_MISRA_CAST_float_widening_cast</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_float_widening_cast</configKey>
<description><![CDATA[ Complex expression cast from 32-bit float to 64-bit float (MISRA 2004 Rule 10.4)]]></description>
</rule>
<rule>
<name>Misra violating cast</name>
<key>STATIC_C_MISRA_CAST_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_generic</configKey>
<description><![CDATA[ Cast operation violates MISRA standard (MISRA 2004 Rules 10.1 - 10.5)]]></description>
</rule>
<rule>
<name>Misra violating cast</name>
<key>STATIC_C_MISRA_CAST_integer_signedness_changing_cast</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_integer_signedness_changing_cast</configKey>
<description><![CDATA[ Complex expression cast from 32-bit int to 32-bit unsigned int (MISRA 2004 Rule 10.3)]]></description>
</rule>
<rule>
<name>Misra violating cast</name>
<key>STATIC_C_MISRA_CAST_integer_to_float_cast</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_integer_to_float_cast</configKey>
<description><![CDATA[ Complex expression cast from int to 64-bit float (MISRA 2004 Rule 10.3)]]></description>
</rule>
<rule>
<name>Misra violating cast</name>
<key>STATIC_C_MISRA_CAST_integer_widening_cast</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_integer_widening_cast</configKey>
<description><![CDATA[ Complex expression with underlying type 16-bit unsigned value cast to wider type 32-bit unsigned value (MISRA 2004 Rule 10.3)]]></description>
</rule>
<rule>
<name>Misra violating cast</name>
<key>STATIC_C_MISRA_CAST_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISRA_CAST_none</configKey>
<description><![CDATA[ Cast operation violates MISRA standard (MISRA 2004 Rules 10.1 - 10.5)]]></description>
</rule>
<rule>
<name>Operands don&apos;t affect result</name>
<key>STATIC_C_CONSTANT_EXPRESSION_RESULT_result_independent_of_operands</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_result_independent_of_operands</configKey>
<description><![CDATA[ An operation with non-constant operands that computes a result with constant value]]></description>
</rule>
<rule>
<name>Overflowed constant</name>
<key>STATIC_C_INTEGER_OVERFLOW_const_overflow</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_INTEGER_OVERFLOW_const_overflow</configKey>
<description><![CDATA[ Integer overflow  occurs in arithmetic on constant operands]]></description>
</rule>
<rule>
<name>Reliance on integer endianness</name>
<key>STATIC_C_INCOMPATIBLE_CAST_endianness</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_INCOMPATIBLE_CAST_endianness</configKey>
<description><![CDATA[ Reliance on integer endianness]]></description>
</rule>
<rule>
<name>Suspicious &amp;= or |=</name>
<key>STATIC_C_CONSTANT_EXPRESSION_RESULT_unnecessary_op_assign</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_unnecessary_op_assign</configKey>
<description><![CDATA[ Using a bitwise assignment operator to assign a constant value]]></description>
</rule>
<rule>
<name>Unintended sign extension</name>
<key>STATIC_C_SIGN_EXTENSION_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_SIGN_EXTENSION_generic</configKey>
<description><![CDATA[ Value may be sign extended unintentionally]]></description>
</rule>
<rule>
<name>Unintended sign extension</name>
<key>STATIC_C_SIGN_EXTENSION_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_SIGN_EXTENSION_none</configKey>
<description><![CDATA[ Value may be sign extended unintentionally]]></description>
</rule>
<rule>
<name>Unintentional integer overflow</name>
<key>STATIC_C_OVERFLOW_BEFORE_WIDEN_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_OVERFLOW_BEFORE_WIDEN_generic</configKey>
<description><![CDATA[ An integer overflow occurs, with the result converted to a wider integer type]]></description>
</rule>
<rule>
<name>Unintentional integer overflow</name>
<key>STATIC_C_OVERFLOW_BEFORE_WIDEN_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_OVERFLOW_BEFORE_WIDEN_none</configKey>
<description><![CDATA[ An integer overflow occurs, with the result converted to a wider integer type]]></description>
</rule>
<rule>
<name>Unsigned compared with neg</name>
<key>STATIC_C_PW.UNSIGNED_COMPARE_WITH_NEGATIVE_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.UNSIGNED_COMPARE_WITH_NEGATIVE_generic</configKey>
<description><![CDATA[ An unsigned value, which can never be less than 0, is compared with a negative value]]></description>
</rule>
<rule>
<name>Unsigned compared with neg</name>
<key>STATIC_C_PW.UNSIGNED_COMPARE_WITH_NEGATIVE_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_PW.UNSIGNED_COMPARE_WITH_NEGATIVE_none</configKey>
<description><![CDATA[ An unsigned value, which can never be less than 0, is compared with a negative value]]></description>
</rule>
<rule>
<name>Wrong operator used</name>
<key>STATIC_C_CONSTANT_EXPRESSION_RESULT_operator_confusion</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_operator_confusion</configKey>
<description><![CDATA[ Wrong operator used in expression]]></description>
</rule>
<rule>
<name>Allocation size error</name>
<key>STATIC_C_OVERRUN_strlen</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_OVERRUN_strlen</configKey>
<description><![CDATA[ Allocation size does not include space for the null-terminator needed for a string]]></description>
</rule>
<rule>
<name>Allocation size error</name>
<key>STATIC_C_OVERRUN_DYNAMIC_strlen</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_OVERRUN_DYNAMIC_strlen</configKey>
<description><![CDATA[ Allocation size does not include space for the null-terminator needed for a string]]></description>
</rule>
<rule>
<name>Allocation size mismatch</name>
<key>STATIC_C_SIZECHECK_incorrect_multiplication</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_SIZECHECK_incorrect_multiplication</configKey>
<description><![CDATA[ Allocation size is not a multiple of the target pointer's pointed-to type]]></description>
</rule>
<rule>
<name>Allocation size with &apos;&amp;&apos;</name>
<key>STATIC_C_SIZECHECK_ampersand_in_size</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_SIZECHECK_ampersand_in_size</configKey>
<description><![CDATA[ Allocation size is computed using the bitwise-and operator (&amp;), which is likely to be a typo]]></description>
</rule>
<rule>
<name>Allocation too small for string</name>
<key>STATIC_C_SIZECHECK_no_null_terminator</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_SIZECHECK_no_null_terminator</configKey>
<description><![CDATA[ Allocation size for a string is equal to the strlen of another string, which does not include extra byte for null termination]]></description>
</rule>
<rule>
<name>Allocation too small for type</name>
<key>STATIC_C_SIZECHECK_likely_overflow</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_SIZECHECK_likely_overflow</configKey>
<description><![CDATA[ Allocation size is too small for the type of object being allocated]]></description>
</rule>
<rule>
<name>Argument cannot be negative</name>
<key>STATIC_C_REVERSE_NEGATIVE_critical_argument</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_REVERSE_NEGATIVE_critical_argument</configKey>
<description><![CDATA[ Negative value used as argument to a function expecting a positive value (for example, size of buffer or allocation)]]></description>
</rule>
<rule>
<name>Buffer overflow</name>
<key>STATIC_C_STRING_OVERFLOW_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_STRING_OVERFLOW_generic</configKey>
<description><![CDATA[ Size of destination buffer is smaller than the size of the source buffer or size of the source buffer is unknown]]></description>
</rule>
<rule>
<name>Buffer overflow</name>
<key>STATIC_C_STRING_OVERFLOW_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_STRING_OVERFLOW_none</configKey>
<description><![CDATA[ Size of destination buffer is smaller than the size of the source buffer or size of the source buffer is unknown]]></description>
</rule>
<rule>
<name>COM bad conversion to BSTR</name>
<key>STATIC_C_COM.BSTR.CONV_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_COM.BSTR.CONV_generic</configKey>
<description><![CDATA[ A wide character string cannot be converted to a BSTR because it lacks the hidden length field]]></description>
</rule>
<rule>
<name>COM bad conversion to BSTR</name>
<key>STATIC_C_COM.BSTR.CONV_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_COM.BSTR.CONV_none</configKey>
<description><![CDATA[ A wide character string cannot be converted to a BSTR because it lacks the hidden length field]]></description>
</rule>
<rule>
<name>Destination buffer too small</name>
<key>STATIC_C_BUFFER_SIZE_likely_overflow</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BUFFER_SIZE_likely_overflow</configKey>
<description><![CDATA[ Size of destination buffer is smaller than the size argument specified]]></description>
</rule>
<rule>
<name>Destination buffer too small</name>
<key>STATIC_C_STRING_OVERFLOW_likely_overflow</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_STRING_OVERFLOW_likely_overflow</configKey>
<description><![CDATA[ Size of destination buffer is smaller than the size of the source buffer]]></description>
</rule>
<rule>
<name>Double free</name>
<key>STATIC_C_USE_AFTER_FREE_double_free</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_USE_AFTER_FREE_double_free</configKey>
<description><![CDATA[ Memory is deallocated more than once]]></description>
</rule>
<rule>
<name>Free of address-of expression</name>
<key>STATIC_C_BAD_FREE_address</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BAD_FREE_address</configKey>
<description><![CDATA[ Free of an address-of expression, which can never be heap allocated]]></description>
</rule>
<rule>
<name>Free of address-of first field</name>
<key>STATIC_C_BAD_FREE_first_field_address</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BAD_FREE_first_field_address</configKey>
<description><![CDATA[ Free of an address-of the first field of a struct]]></description>
</rule>
<rule>
<name>Free of array-typed value</name>
<key>STATIC_C_BAD_FREE_array</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BAD_FREE_array</configKey>
<description><![CDATA[ Free of array-typed value]]></description>
</rule>
<rule>
<name>Free of function pointer</name>
<key>STATIC_C_BAD_FREE_function_pointer</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BAD_FREE_function_pointer</configKey>
<description><![CDATA[ Free of function pointer]]></description>
</rule>
<rule>
<name>Free of invalid pointer value</name>
<key>STATIC_C_BAD_FREE_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BAD_FREE_generic</configKey>
<description><![CDATA[ Free of an pointer that was not returned from an allocation function]]></description>
</rule>
<rule>
<name>Free of invalid pointer value</name>
<key>STATIC_C_BAD_FREE_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BAD_FREE_none</configKey>
<description><![CDATA[ Free of an pointer that was not returned from an allocation function]]></description>
</rule>
<rule>
<name>Free of stack-allocated memory</name>
<key>STATIC_C_BAD_FREE_alloca</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BAD_FREE_alloca</configKey>
<description><![CDATA[ Free of stack-allocated buffer]]></description>
</rule>
<rule>
<name>Freed COM internal write</name>
<key>STATIC_C_WRAPPER_ESCAPE_COM_deref_write_after_free</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_WRAPPER_ESCAPE_COM_deref_write_after_free</configKey>
<description><![CDATA[ Write to target of a freed internal pointer of a COM object]]></description>
</rule>
<rule>
<name>Freed internal location write</name>
<key>STATIC_C_WRAPPER_ESCAPE_deref_write_after_free</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_WRAPPER_ESCAPE_deref_write_after_free</configKey>
<description><![CDATA[ Write to target of a freed internal pointer]]></description>
</rule>
<rule>
<name>Illegal address computation</name>
<key>STATIC_C_OVERRUN_illegal_address</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_OVERRUN_illegal_address</configKey>
<description><![CDATA[ An illegal address is computed, which either precedes a buffer or is more than just-past its end]]></description>
</rule>
<rule>
<name>Incorrect operator new syntax</name>
<key>STATIC_C_SIZECHECK_improper_new</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_SIZECHECK_improper_new</configKey>
<description><![CDATA[ This invocation of operator new only creates one value, not an array of values]]></description>
</rule>
<rule>
<name>Iterator container mismatch</name>
<key>STATIC_C_MISMATCHED_ITERATOR_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_MISMATCHED_ITERATOR_generic</configKey>
<description><![CDATA[ Using iterator from one container in operations on another container]]></description>
</rule>
<rule>
<name>Iterator container mismatch</name>
<key>STATIC_C_MISMATCHED_ITERATOR_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_MISMATCHED_ITERATOR_none</configKey>
<description><![CDATA[ Using iterator from one container in operations on another container]]></description>
</rule>
<rule>
<name>Negative array index write</name>
<key>STATIC_C_NEGATIVE_RETURNS_array_index_write</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_NEGATIVE_RETURNS_array_index_write</configKey>
<description><![CDATA[ Negative value used to index an array in a write operation]]></description>
</rule>
<rule>
<name>Negative array index write</name>
<key>STATIC_C_REVERSE_NEGATIVE_array_index_write</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_REVERSE_NEGATIVE_array_index_write</configKey>
<description><![CDATA[ Write to array at negative index]]></description>
</rule>
<rule>
<name>Out-of-bounds access</name>
<key>STATIC_C_ARRAY_VS_SINGLETON_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_ARRAY_VS_SINGLETON_generic</configKey>
<description><![CDATA[ Access of memory past the end of a memory buffer]]></description>
</rule>
<rule>
<name>Out-of-bounds access</name>
<key>STATIC_C_ARRAY_VS_SINGLETON_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_ARRAY_VS_SINGLETON_none</configKey>
<description><![CDATA[ Access of memory past the end of a memory buffer]]></description>
</rule>
<rule>
<name>Out-of-bounds access</name>
<key>STATIC_C_OVERRUN_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_OVERRUN_generic</configKey>
<description><![CDATA[ Out-of-bounds access to a buffer]]></description>
</rule>
<rule>
<name>Out-of-bounds access</name>
<key>STATIC_C_OVERRUN_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_OVERRUN_none</configKey>
<description><![CDATA[ Out-of-bounds access to a buffer]]></description>
</rule>
<rule>
<name>Out-of-bounds access</name>
<key>STATIC_C_OVERRUN_DYNAMIC_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_OVERRUN_DYNAMIC_generic</configKey>
<description><![CDATA[ Out-of-bounds access to an array]]></description>
</rule>
<rule>
<name>Out-of-bounds access</name>
<key>STATIC_C_OVERRUN_DYNAMIC_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_OVERRUN_DYNAMIC_none</configKey>
<description><![CDATA[ Out-of-bounds access to an array]]></description>
</rule>
<rule>
<name>Out-of-bounds access</name>
<key>STATIC_C_OVERRUN_STATIC_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_OVERRUN_STATIC_generic</configKey>
<description><![CDATA[ Out-of-bounds access to an array]]></description>
</rule>
<rule>
<name>Out-of-bounds access</name>
<key>STATIC_C_OVERRUN_STATIC_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_OVERRUN_STATIC_none</configKey>
<description><![CDATA[ Out-of-bounds access to an array]]></description>
</rule>
<rule>
<name>Out-of-bounds write</name>
<key>STATIC_C_OVERRUN_write</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_OVERRUN_write</configKey>
<description><![CDATA[ Out-of-bounds write to a buffer]]></description>
</rule>
<rule>
<name>Out-of-bounds write</name>
<key>STATIC_C_OVERRUN_DYNAMIC_write</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_OVERRUN_DYNAMIC_write</configKey>
<description><![CDATA[ Out-of-bounds write to a dynamically allocated buffer]]></description>
</rule>
<rule>
<name>Out-of-bounds write</name>
<key>STATIC_C_OVERRUN_STATIC_write</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_OVERRUN_STATIC_write</configKey>
<description><![CDATA[ Out-of-bounds write to an array]]></description>
</rule>
<rule>
<name>Overflowed array index write</name>
<key>STATIC_C_INTEGER_OVERFLOW_array_index_write</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_INTEGER_OVERFLOW_array_index_write</configKey>
<description><![CDATA[ Write to array at integer-overflowed index]]></description>
</rule>
<rule>
<name>Overflowed pointer write</name>
<key>STATIC_C_INTEGER_OVERFLOW_pointer_deref_write</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_INTEGER_OVERFLOW_pointer_deref_write</configKey>
<description><![CDATA[ Write to target of an integer-overflowed pointer]]></description>
</rule>
<rule>
<name>Splice iterator mismatch</name>
<key>STATIC_C_MISMATCHED_ITERATOR_splice_iterator_mismatch</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_MISMATCHED_ITERATOR_splice_iterator_mismatch</configKey>
<description><![CDATA[ Using iterator from the wrong container as argument to the splice method]]></description>
</rule>
<rule>
<name>Stray pointer arithmetic</name>
<key>STATIC_C_BAD_ALLOC_ARITHMETIC_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BAD_ALLOC_ARITHMETIC_generic</configKey>
<description><![CDATA[ Pointer arithmetic performed on freshly allocated memory]]></description>
</rule>
<rule>
<name>Stray pointer arithmetic</name>
<key>STATIC_C_BAD_ALLOC_ARITHMETIC_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BAD_ALLOC_ARITHMETIC_none</configKey>
<description><![CDATA[ Pointer arithmetic performed on freshly allocated memory]]></description>
</rule>
<rule>
<name>String length miscalculation</name>
<key>STATIC_C_BAD_ALLOC_STRLEN_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BAD_ALLOC_STRLEN_generic</configKey>
<description><![CDATA[ String length miscalculation]]></description>
</rule>
<rule>
<name>String length miscalculation</name>
<key>STATIC_C_BAD_ALLOC_STRLEN_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BAD_ALLOC_STRLEN_none</configKey>
<description><![CDATA[ String length miscalculation]]></description>
</rule>
<rule>
<name>Symbian - double free</name>
<key>STATIC_C_SYMBIAN.CLEANUP_STACK_double_free</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_SYMBIAN.CLEANUP_STACK_double_free</configKey>
<description><![CDATA[ An object is freed twice because it is explicitly freed twice, on the cleanup stack more than once, or it is deallocated but still on the cleanup stack]]></description>
</rule>
<rule>
<name>Unbounded source buffer</name>
<key>STATIC_C_STRING_SIZE_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_STRING_SIZE_generic</configKey>
<description><![CDATA[ A source buffer of arbitrarily large size is used where a fixed-size destination buffer is expected]]></description>
</rule>
<rule>
<name>Unbounded source buffer</name>
<key>STATIC_C_STRING_SIZE_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_STRING_SIZE_none</configKey>
<description><![CDATA[ A source buffer of arbitrarily large size is used where a fixed-size destination buffer is expected]]></description>
</rule>
<rule>
<name>Uninitialized array index write</name>
<key>STATIC_C_UNINIT_array_index_write</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_UNINIT_array_index_write</configKey>
<description><![CDATA[ Write to array at uninitialized index]]></description>
</rule>
<rule>
<name>Uninitialized pointer write</name>
<key>STATIC_C_UNINIT_pointer_deref_write</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_UNINIT_pointer_deref_write</configKey>
<description><![CDATA[ Write to target of an uninitialized pointer]]></description>
</rule>
<rule>
<name>Write to pointer after free</name>
<key>STATIC_C_USE_AFTER_FREE_deref_write_after_free</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_USE_AFTER_FREE_deref_write_after_free</configKey>
<description><![CDATA[ Write to target of a freed pointer]]></description>
</rule>
<rule>
<name>Allocation size error</name>
<key>STATIC_C_SIZECHECK_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_SIZECHECK_generic</configKey>
<description><![CDATA[ The allocation size is computed incorrectly]]></description>
</rule>
<rule>
<name>Allocation size error</name>
<key>STATIC_C_SIZECHECK_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_SIZECHECK_none</configKey>
<description><![CDATA[ The allocation size is computed incorrectly]]></description>
</rule>
<rule>
<name>Array delete misuse</name>
<key>STATIC_C_DELETE_ARRAY_non_array_delete</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_DELETE_ARRAY_non_array_delete</configKey>
<description><![CDATA[ Using array delete on a non-array]]></description>
</rule>
<rule>
<name>Buffer not null terminated</name>
<key>STATIC_C_BUFFER_SIZE_no_null_terminator</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BUFFER_SIZE_no_null_terminator</configKey>
<description><![CDATA[ The string buffer may not have a null terminator if the source string's length is equal to the buffer size]]></description>
</rule>
<rule>
<name>Buffer not null terminated</name>
<key>STATIC_C_BUFFER_SIZE_WARNING_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BUFFER_SIZE_WARNING_generic</configKey>
<description><![CDATA[ The string buffer may not have a null terminator if the source string's length is equal to the buffer size]]></description>
</rule>
<rule>
<name>Buffer not null terminated</name>
<key>STATIC_C_BUFFER_SIZE_WARNING_no_null_terminator</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BUFFER_SIZE_WARNING_no_null_terminator</configKey>
<description><![CDATA[ The string buffer may not have a null terminator if the source string's length is equal to the buffer size]]></description>
</rule>
<rule>
<name>Buffer not null terminated</name>
<key>STATIC_C_BUFFER_SIZE_WARNING_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_BUFFER_SIZE_WARNING_none</configKey>
<description><![CDATA[ The string buffer may not have a null terminator if the source string's length is equal to the buffer size]]></description>
</rule>
<rule>
<name>COM BSTR double free</name>
<key>STATIC_C_COM.BSTR.ALLOC_double_free</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_COM.BSTR.ALLOC_double_free</configKey>
<description><![CDATA[ Violation of the COM coding standard by freeing a BSTR more than once]]></description>
</rule>
<rule>
<name>COM BSTR error</name>
<key>STATIC_C_COM.BSTR.ALLOC_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_COM.BSTR.ALLOC_generic</configKey>
<description><![CDATA[ Violation of the COM coding standard by not freeing a BSTR, by using an uninitialized BSTR, or by freeing a non-owned BSTR]]></description>
</rule>
<rule>
<name>COM BSTR error</name>
<key>STATIC_C_COM.BSTR.ALLOC_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_COM.BSTR.ALLOC_none</configKey>
<description><![CDATA[ Violation of the COM coding standard by not freeing a BSTR, or by freeing a non-owned BSTR]]></description>
</rule>
<rule>
<name>COM BSTR uninitialized var free</name>
<key>STATIC_C_COM.BSTR.ALLOC_free_uninit</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_COM.BSTR.ALLOC_free_uninit</configKey>
<description><![CDATA[ Violation of the COM coding standard by freeing an uninitialized BSTR]]></description>
</rule>
<rule>
<name>COM BSTR uninitialized var use</name>
<key>STATIC_C_COM.BSTR.ALLOC_use_uninit</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_COM.BSTR.ALLOC_use_uninit</configKey>
<description><![CDATA[ Violation of the COM coding standard by using an uninitialized BSTR]]></description>
</rule>
<rule>
<name>COM object use after free</name>
<key>STATIC_C_WRAPPER_ESCAPE_COM_use_after_free</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_WRAPPER_ESCAPE_COM_use_after_free</configKey>
<description><![CDATA[ An internal pointer of a COM string object remains available after the object is freed]]></description>
</rule>
<rule>
<name>Explicit free of COM interface</name>
<key>STATIC_C_COM.BAD_FREE_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_COM.BAD_FREE_generic</configKey>
<description><![CDATA[ A COM interface is explicitly freed instead of using the recommended Release method]]></description>
</rule>
<rule>
<name>Explicit free of COM interface</name>
<key>STATIC_C_COM.BAD_FREE_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_COM.BAD_FREE_none</configKey>
<description><![CDATA[ A COM interface is explicitly freed instead of using the recommended Release method]]></description>
</rule>
<rule>
<name>Freed COM internal read</name>
<key>STATIC_C_WRAPPER_ESCAPE_COM_deref_read_after_free</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_WRAPPER_ESCAPE_COM_deref_read_after_free</configKey>
<description><![CDATA[ Reads target of a freed internal pointer of a COM object]]></description>
</rule>
<rule>
<name>Freed internal location read</name>
<key>STATIC_C_WRAPPER_ESCAPE_deref_read_after_free</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_WRAPPER_ESCAPE_deref_read_after_free</configKey>
<description><![CDATA[ Reads target of a freed internal pointer]]></description>
</rule>
<rule>
<name>Freeing non-owned COM BSTR</name>
<key>STATIC_C_COM.BSTR.ALLOC_use_after_free</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_COM.BSTR.ALLOC_use_after_free</configKey>
<description><![CDATA[ Violation of the COM coding standard by freeing a non-owned BSTR]]></description>
</rule>
<rule>
<name>Incorrect delete operator</name>
<key>STATIC_C_DELETE_ARRAY_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_DELETE_ARRAY_generic</configKey>
<description><![CDATA[ Using non-array delete on an array of objects, scalars, or pointers allocated with new[]]]></description>
</rule>
<rule>
<name>Incorrect delete operator</name>
<key>STATIC_C_DELETE_ARRAY_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_DELETE_ARRAY_none</configKey>
<description><![CDATA[ Using non-array delete on an array of objects, scalars, or pointers allocated with new[]]]></description>
</rule>
<rule>
<name>Memset buffer size of 0</name>
<key>STATIC_C_NO_EFFECT_bad_memset_zero_size</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_NO_EFFECT_bad_memset_zero_size</configKey>
<description><![CDATA[ A memset buffer size of 0 may indicate confusing the size and fill parameters]]></description>
</rule>
<rule>
<name>Memset fill truncated</name>
<key>STATIC_C_NO_EFFECT_bad_memset_truncated_fill</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_NO_EFFECT_bad_memset_truncated_fill</configKey>
<description><![CDATA[ The memset fill value must be between -1 and 255, other values will be truncated]]></description>
</rule>
<rule>
<name>Memset fill value of &apos;0&apos;</name>
<key>STATIC_C_NO_EFFECT_bad_memset_fill_value</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_NO_EFFECT_bad_memset_fill_value</configKey>
<description><![CDATA[ A memset fill value of ASCII character '0' is likely intended to be 0]]></description>
</rule>
<rule>
<name>Missing parentheses</name>
<key>STATIC_C_SIZEOF_MISMATCH_missing_parentheses</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_SIZEOF_MISMATCH_missing_parentheses</configKey>
<description><![CDATA[ Missing parentheses caused unintended operator precedence of casting before the pointer arithmetic]]></description>
</rule>
<rule>
<name>Negative array index read</name>
<key>STATIC_C_NEGATIVE_RETURNS_array_index_read</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_NEGATIVE_RETURNS_array_index_read</configKey>
<description><![CDATA[ Negative value used to index an array in a read operation]]></description>
</rule>
<rule>
<name>Negative array index read</name>
<key>STATIC_C_REVERSE_NEGATIVE_array_index_read</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_REVERSE_NEGATIVE_array_index_read</configKey>
<description><![CDATA[ Read from array at negative index]]></description>
</rule>
<rule>
<name>Out-of-bounds access</name>
<key>STATIC_C_INCOMPATIBLE_CAST_overrun</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_INCOMPATIBLE_CAST_overrun</configKey>
<description><![CDATA[ Out-of-bounds access to a scalar]]></description>
</rule>
<rule>
<name>Out-of-bounds read</name>
<key>STATIC_C_OVERRUN_read</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_OVERRUN_read</configKey>
<description><![CDATA[ Out-of-bounds read from a buffer]]></description>
</rule>
<rule>
<name>Out-of-bounds read</name>
<key>STATIC_C_OVERRUN_DYNAMIC_read</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_OVERRUN_DYNAMIC_read</configKey>
<description><![CDATA[ Out-of-bounds read from a dynamically allocated buffer]]></description>
</rule>
<rule>
<name>Out-of-bounds read</name>
<key>STATIC_C_OVERRUN_STATIC_read</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_OVERRUN_STATIC_read</configKey>
<description><![CDATA[ Out-of-bounds read from an array]]></description>
</rule>
<rule>
<name>Overflowed array index read</name>
<key>STATIC_C_INTEGER_OVERFLOW_array_index_read</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_INTEGER_OVERFLOW_array_index_read</configKey>
<description><![CDATA[ Read from array at integer overflowed index]]></description>
</rule>
<rule>
<name>Overflowed pointer read</name>
<key>STATIC_C_INTEGER_OVERFLOW_pointer_deref_read</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_INTEGER_OVERFLOW_pointer_deref_read</configKey>
<description><![CDATA[ Reads target of an integer-overflowed pointer]]></description>
</rule>
<rule>
<name>Pointer to local outside scope</name>
<key>STATIC_C_RETURN_LOCAL_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_RETURN_LOCAL_generic</configKey>
<description><![CDATA[ Pointer to a local stack variable returned or used outside scope]]></description>
</rule>
<rule>
<name>Pointer to local outside scope</name>
<key>STATIC_C_RETURN_LOCAL_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_RETURN_LOCAL_none</configKey>
<description><![CDATA[ Pointer to a local stack variable returned or used outside scope]]></description>
</rule>
<rule>
<name>Read from pointer after free</name>
<key>STATIC_C_USE_AFTER_FREE_deref_read_after_free</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_USE_AFTER_FREE_deref_read_after_free</configKey>
<description><![CDATA[ Reads target of a freed pointer]]></description>
</rule>
<rule>
<name>Readlink used insecurely</name>
<key>STATIC_C_READLINK_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_READLINK_generic</configKey>
<description><![CDATA[ The readlink system call may return a value equal to the buffer size, which causes an access one past the end]]></description>
</rule>
<rule>
<name>Readlink used insecurely</name>
<key>STATIC_C_READLINK_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_READLINK_none</configKey>
<description><![CDATA[ The readlink system call may return a value equal to the buffer size, which causes an access one past the end]]></description>
</rule>
<rule>
<name>Returning pointer to temp</name>
<key>STATIC_C_PW.RETURN_PTR_TO_LOCAL_TEMP_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_PW.RETURN_PTR_TO_LOCAL_TEMP_generic</configKey>
<description><![CDATA[ Returning a pointer to a temporary variable, which will be destroyed on function exit]]></description>
</rule>
<rule>
<name>Returning pointer to temp</name>
<key>STATIC_C_PW.RETURN_PTR_TO_LOCAL_TEMP_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_PW.RETURN_PTR_TO_LOCAL_TEMP_none</configKey>
<description><![CDATA[ Returning a pointer to a temporary variable, which will be destroyed on function exit]]></description>
</rule>
<rule>
<name>String not null terminated</name>
<key>STATIC_C_STRING_NULL_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_STRING_NULL_generic</configKey>
<description><![CDATA[ A character buffer that has not been null terminated is passed to a function expecting a null terminated string]]></description>
</rule>
<rule>
<name>String not null terminated</name>
<key>STATIC_C_STRING_NULL_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_STRING_NULL_none</configKey>
<description><![CDATA[ A character buffer that has not been null terminated is passed to a function expecting a null terminated string]]></description>
</rule>
<rule>
<name>Uninitialized array index read</name>
<key>STATIC_C_UNINIT_array_index_read</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_UNINIT_array_index_read</configKey>
<description><![CDATA[ Read from array at uninitialized index]]></description>
</rule>
<rule>
<name>Non-array delete for scalars</name>
<key>STATIC_C_DELETE_ARRAY_scalar</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_DELETE_ARRAY_scalar</configKey>
<description><![CDATA[ Using non-array delete on an array of scalars or pointers allocated with new[]]]></description>
</rule>
<rule>
<name>Uninitialized pointer read</name>
<key>STATIC_C_UNINIT_pointer_deref_read</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_UNINIT_pointer_deref_read</configKey>
<description><![CDATA[ Reads an uninitialized pointer or its target]]></description>
</rule>
<rule>
<name>Use after free</name>
<key>STATIC_C_USE_AFTER_FREE_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_USE_AFTER_FREE_generic</configKey>
<description><![CDATA[ A pointer to freed memory is  dereferenced, used as a function argument, or otherwise used]]></description>
</rule>
<rule>
<name>Use after free</name>
<key>STATIC_C_USE_AFTER_FREE_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_USE_AFTER_FREE_none</configKey>
<description><![CDATA[ A pointer to freed memory is  dereferenced, used as a function argument, or otherwise used]]></description>
</rule>
<rule>
<name>Wrapper object use after free</name>
<key>STATIC_C_WRAPPER_ESCAPE_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_WRAPPER_ESCAPE_generic</configKey>
<description><![CDATA[ An internal pointer of a wrapper object remains available after the object is freed]]></description>
</rule>
<rule>
<name>Wrapper object use after free</name>
<key>STATIC_C_WRAPPER_ESCAPE_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_WRAPPER_ESCAPE_none</configKey>
<description><![CDATA[ An internal pointer of a wrapper object remains available after the object is freed]]></description>
</rule>
<rule>
<name>Dereference after null check</name>
<key>STATIC_C_FORWARD_NULL_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_FORWARD_NULL_none</configKey>
<description><![CDATA[ Pointer is checked against null but then dereferenced anyway]]></description>
</rule>
<rule>
<name>Dereference before null check</name>
<key>STATIC_C_REVERSE_INULL_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_REVERSE_INULL_generic</configKey>
<description><![CDATA[ All paths that lead to this null pointer comparison already dereference the pointer earlier]]></description>
</rule>
<rule>
<name>Dereference before null check</name>
<key>STATIC_C_REVERSE_INULL_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_REVERSE_INULL_none</configKey>
<description><![CDATA[ All paths that lead to this null pointer comparison already dereference the pointer earlier]]></description>
</rule>
<rule>
<name>Dereference null return (stat)</name>
<key>STATIC_C_NULL_RETURNS_unimpl</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NULL_RETURNS_unimpl</configKey>
<description><![CDATA[ Return value of function, which is statistically inferred to return null, but with no source code available, is dereferenced]]></description>
</rule>
<rule>
<name>Dereference null return value</name>
<key>STATIC_C_NULL_RETURNS_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NULL_RETURNS_generic</configKey>
<description><![CDATA[ Return value of function which returns null is dereferenced without checking]]></description>
</rule>
<rule>
<name>Dereference null return value</name>
<key>STATIC_C_NULL_RETURNS_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NULL_RETURNS_none</configKey>
<description><![CDATA[ Return value of function which returns null is dereferenced without checking]]></description>
</rule>
<rule>
<name>Explicit null dereferenced</name>
<key>STATIC_C_FORWARD_NULL_deref_constant_null</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_FORWARD_NULL_deref_constant_null</configKey>
<description><![CDATA[ Dereference of an explicit null value]]></description>
</rule>
<rule>
<name>Null pointer dereference</name>
<key>STATIC_C_FORWARD_NULL_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_FORWARD_NULL_generic</configKey>
<description><![CDATA[ Pointer is checked against null or assigned to null and then dereferenced]]></description>
</rule>
<rule>
<name>Unchecked dynamic_cast</name>
<key>STATIC_C_FORWARD_NULL_dynamic_cast</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_FORWARD_NULL_dynamic_cast</configKey>
<description><![CDATA[ Dynamic_cast may fail and return null if the type cast is incompatible]]></description>
</rule>
<rule>
<name>Parse recovery warning</name>
<key>STATIC_C_RW.*_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_RW.*_generic</configKey>
<description><![CDATA[ A parse error caused a function to be skipped by Coverity Static Analysis]]></description>
</rule>
<rule>
<name>Parse recovery warning</name>
<key>STATIC_C_RW.*_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_RW.*_none</configKey>
<description><![CDATA[ A parse error caused a function to be skipped by Coverity Static Analysis]]></description>
</rule>
<rule>
<name>Parse semantic warning</name>
<key>STATIC_C_SW.*_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_SW.*_generic</configKey>
<description><![CDATA[ The function contains a non-portable or non-standard construct forcing the Coverity parser to guess the meaning]]></description>
</rule>
<rule>
<name>Parse semantic warning</name>
<key>STATIC_C_SW.*_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_SW.*_none</configKey>
<description><![CDATA[ The function contains a non-portable or non-standard construct forcing the Coverity parser to guess the meaning]]></description>
</rule>
<rule>
<name>Parse warning</name>
<key>STATIC_C_PW.*_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_PW.*_generic</configKey>
<description><![CDATA[ A parse warning from the Coverity parser may indicate a bug, or poor coding practice]]></description>
</rule>
<rule>
<name>Parse warning</name>
<key>STATIC_C_PW.*_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_PW.*_none</configKey>
<description><![CDATA[ A parse warning from the Coverity parser may indicate a bug, or poor coding practice]]></description>
</rule>
<rule>
<name>Unrecoverable parse warning</name>
<key>STATIC_C_PARSE_ERROR_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_PARSE_ERROR_generic</configKey>
<description><![CDATA[ A parse error caused an entire compilation unit to be skipped by Coverity Static Analysis]]></description>
</rule>
<rule>
<name>Unrecoverable parse warning</name>
<key>STATIC_C_PARSE_ERROR_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_PARSE_ERROR_none</configKey>
<description><![CDATA[ A parse error caused an entire compilation unit to be skipped by Coverity Static Analysis]]></description>
</rule>
<rule>
<name>Large stack use</name>
<key>STATIC_C_STACK_USE_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_STACK_USE_generic</configKey>
<description><![CDATA[ Excessive use of stack memory by local variables or parameters]]></description>
</rule>
<rule>
<name>Large stack use</name>
<key>STATIC_C_STACK_USE_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_STACK_USE_none</configKey>
<description><![CDATA[ Excessive use of stack memory by local variables or parameters]]></description>
</rule>
<rule>
<name>Double lock</name>
<key>STATIC_C_LOCK_double_lock</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_LOCK_double_lock</configKey>
<description><![CDATA[ Attempt to acquire a lock more than once on a non-recursive lock]]></description>
</rule>
<rule>
<name>Double lock or missing unlock</name>
<key>STATIC_C_LOCK_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_LOCK_none</configKey>
<description><![CDATA[ Missing a release of a lock on a path, or an attempt to acquire a lock more than once]]></description>
</rule>
<rule>
<name>Missing unlock</name>
<key>STATIC_C_LOCK_missing_unlock</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_LOCK_missing_unlock</configKey>
<description><![CDATA[ Missing a release of a lock on a path]]></description>
</rule>
<rule>
<name>Missing/extra lock or unlock</name>
<key>STATIC_C_LOCK_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_LOCK_generic</configKey>
<description><![CDATA[ Missing a release or acquire of a lock on a path, or an attempt to acquire a lock more than once]]></description>
</rule>
<rule>
<name>Negative loop bound</name>
<key>STATIC_C_NEGATIVE_RETURNS_loop_bound</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_NEGATIVE_RETURNS_loop_bound</configKey>
<description><![CDATA[ Negative value used as a loop upper bound]]></description>
</rule>
<rule>
<name>Thread deadlock</name>
<key>STATIC_C_ORDER_REVERSAL_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_ORDER_REVERSAL_generic</configKey>
<description><![CDATA[ Threads may try to acquire two locks in different orders, potentially causing deadlock]]></description>
</rule>
<rule>
<name>Thread deadlock</name>
<key>STATIC_C_ORDER_REVERSAL_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_ORDER_REVERSAL_none</configKey>
<description><![CDATA[ Threads may try to acquire two locks in different orders, potentially causing deadlock]]></description>
</rule>
<rule>
<name>Infinite loop</name>
<key>STATIC_C_INFINITE_LOOP_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_INFINITE_LOOP_generic</configKey>
<description><![CDATA[ Infinite loop with unsatisfiable or no exit condition]]></description>
</rule>
<rule>
<name>Infinite loop</name>
<key>STATIC_C_INFINITE_LOOP_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_INFINITE_LOOP_none</configKey>
<description><![CDATA[ Infinite loop with unsatisfiable exit condition]]></description>
</rule>
<rule>
<name>Infinite loop with no exit</name>
<key>STATIC_C_INFINITE_LOOP_no_escape</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_INFINITE_LOOP_no_escape</configKey>
<description><![CDATA[ Infinite loop with no exit condition]]></description>
</rule>
<rule>
<name>Waiting while holding a lock</name>
<key>STATIC_C_SLEEP_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_SLEEP_generic</configKey>
<description><![CDATA[ A lock is held while waiting for a long running or blocking operation to complete]]></description>
</rule>
<rule>
<name>Waiting while holding a lock</name>
<key>STATIC_C_SLEEP_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_SLEEP_none</configKey>
<description><![CDATA[ A lock is held while waiting for a long running or blocking operation to complete]]></description>
</rule>
<rule>
<name>COM BSTR memory leak</name>
<key>STATIC_C_COM.BSTR.ALLOC_leak</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_COM.BSTR.ALLOC_leak</configKey>
<description><![CDATA[ Violation of the COM coding standard by not freeing a BSTR whose last reference is lost in this function]]></description>
</rule>
<rule>
<name>Incomplete delete</name>
<key>STATIC_C_NO_EFFECT_incomplete_delete</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_NO_EFFECT_incomplete_delete</configKey>
<description><![CDATA[ Delete operator only applies to one argument in a comma expression, may cause memory leak]]></description>
</rule>
<rule>
<name>Integer handle or fd leak</name>
<key>STATIC_C_RESOURCE_LEAK_fds_handles</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_RESOURCE_LEAK_fds_handles</configKey>
<description><![CDATA[ Leak of a system resource with an integer descriptor such as a file descriptor or a handle in Windows]]></description>
</rule>
<rule>
<name>Non-array delete for objects</name>
<key>STATIC_C_DELETE_ARRAY_object</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_DELETE_ARRAY_object</configKey>
<description><![CDATA[ Using non-array delete on an array of objects; should be using delete[]]]></description>
</rule>
<rule>
<name>Non-virtual destructor</name>
<key>STATIC_C_VIRTUAL_DTOR_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_VIRTUAL_DTOR_generic</configKey>
<description><![CDATA[ The correct derived class destructor is not invoked due to the absence of a virtual destructor in the base class]]></description>
</rule>
<rule>
<name>Non-virtual destructor</name>
<key>STATIC_C_VIRTUAL_DTOR_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_VIRTUAL_DTOR_none</configKey>
<description><![CDATA[ The correct derived class destructor is not invoked due to the absence of a virtual destructor in the base class]]></description>
</rule>
<rule>
<name>Resource leak</name>
<key>STATIC_C_RESOURCE_LEAK_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_RESOURCE_LEAK_generic</configKey>
<description><![CDATA[ Leak of a system resource such as memory, file handles, or sockets]]></description>
</rule>
<rule>
<name>Resource leak</name>
<key>STATIC_C_RESOURCE_LEAK_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_RESOURCE_LEAK_none</configKey>
<description><![CDATA[ Leak of memory or pointers to system resources]]></description>
</rule>
<rule>
<name>Resource leak in object</name>
<key>STATIC_C_CTOR_DTOR_LEAK_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_CTOR_DTOR_LEAK_generic</configKey>
<description><![CDATA[ Constructor allocates memory but destructor does not free it]]></description>
</rule>
<rule>
<name>Resource leak in object</name>
<key>STATIC_C_CTOR_DTOR_LEAK_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_CTOR_DTOR_LEAK_none</configKey>
<description><![CDATA[ Constructor allocates memory but destructor does not free it]]></description>
</rule>
<rule>
<name>Symbian - cleanup stack bug</name>
<key>STATIC_C_SYMBIAN.CLEANUP_STACK_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_SYMBIAN.CLEANUP_STACK_generic</configKey>
<description><![CDATA[ Error in the interaction of the code with the Symbian cleanup stack API]]></description>
</rule>
<rule>
<name>Symbian - cleanup stack bug</name>
<key>STATIC_C_SYMBIAN.CLEANUP_STACK_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_SYMBIAN.CLEANUP_STACK_none</configKey>
<description><![CDATA[ Error in the interaction of the code with the Symbian cleanup stack API]]></description>
</rule>
<rule>
<name>Symbian - cleanup stack leak</name>
<key>STATIC_C_SYMBIAN.CLEANUP_STACK_leak</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_SYMBIAN.CLEANUP_STACK_leak</configKey>
<description><![CDATA[ An object is not on the cleanup stack when a leave occurs or an allocated object goes out of scope, causing a leak]]></description>
</rule>
<rule>
<name>Copy without assign</name>
<key>STATIC_C_COPY_WITHOUT_ASSIGN_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_COPY_WITHOUT_ASSIGN_none</configKey>
<description><![CDATA[ Class has user-written copy constructor but no user-written assignment operator]]></description>
</rule>
<rule>
<name>Calling risky function</name>
<key>STATIC_C_SECURE_CODING_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_SECURE_CODING_generic</configKey>
<description><![CDATA[ Calling a function which may pose a security risk if it is used inappropriately]]></description>
</rule>
<rule>
<name>Calling risky function</name>
<key>STATIC_C_SECURE_CODING_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_SECURE_CODING_none</configKey>
<description><![CDATA[ Calling a function which may pose a security risk if it is used inappropriately]]></description>
</rule>
<rule>
<name>Copy into fixed size buffer</name>
<key>STATIC_C_BUFFER_SIZE_fixed_size_dest</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_BUFFER_SIZE_fixed_size_dest</configKey>
<description><![CDATA[ A source buffer of statically unknown size is copied into a fixed-size destination buffer]]></description>
</rule>
<rule>
<name>Copy into fixed size buffer</name>
<key>STATIC_C_STRING_OVERFLOW_fixed_size_dest</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_STRING_OVERFLOW_fixed_size_dest</configKey>
<description><![CDATA[ A source buffer of statically unknown size is copied into a fixed-size destination buffer]]></description>
</rule>
<rule>
<name>Format string warning</name>
<key>STATIC_C_TAINTED_STRING_WARNING_format_string</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_TAINTED_STRING_WARNING_format_string</configKey>
<description><![CDATA[ A non-constant string used to construct a format string]]></description>
</rule>
<rule>
<name>Format string warning</name>
<key>STATIC_C_TAINTED_STRING_WARNING_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_TAINTED_STRING_WARNING_generic</configKey>
<description><![CDATA[ A non-constant string used to construct a format string]]></description>
</rule>
<rule>
<name>Format string warning</name>
<key>STATIC_C_TAINTED_STRING_WARNING_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_TAINTED_STRING_WARNING_none</configKey>
<description><![CDATA[ A non-constant string used to construct a format string]]></description>
</rule>
<rule>
<name>Insecure temporary file</name>
<key>STATIC_C_SECURE_TEMP_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_SECURE_TEMP_generic</configKey>
<description><![CDATA[ Using an insecure temporary file creation function]]></description>
</rule>
<rule>
<name>Insecure temporary file</name>
<key>STATIC_C_SECURE_TEMP_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_SECURE_TEMP_none</configKey>
<description><![CDATA[ Using an insecure temporary file creation function]]></description>
</rule>
<rule>
<name>Non-constant format string</name>
<key>STATIC_C_PW.NON_CONST_PRINTF_FORMAT_STRING_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_PW.NON_CONST_PRINTF_FORMAT_STRING_generic</configKey>
<description><![CDATA[ A non-constant printf format string may be susceptible to format string attacks]]></description>
</rule>
<rule>
<name>Non-constant format string</name>
<key>STATIC_C_PW.NON_CONST_PRINTF_FORMAT_STRING_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_PW.NON_CONST_PRINTF_FORMAT_STRING_none</configKey>
<description><![CDATA[ A non-constant printf format string may be susceptible to format string attacks]]></description>
</rule>
<rule>
<name>Possible buffer overflow</name>
<key>STATIC_C_BUFFER_SIZE_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_BUFFER_SIZE_generic</configKey>
<description><![CDATA[ Incorrect buffer manipulation using the wrong sizes may result in buffer overflow]]></description>
</rule>
<rule>
<name>Possible buffer overflow</name>
<key>STATIC_C_BUFFER_SIZE_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_BUFFER_SIZE_none</configKey>
<description><![CDATA[ Incorrect buffer manipulation may result in buffer overflow]]></description>
</rule>
<rule>
<name>Time of check time of use</name>
<key>STATIC_C_TOCTOU_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_TOCTOU_generic</configKey>
<description><![CDATA[ A check occurs on a file's attributes before the file is used in a privileged operation, but things may have changed]]></description>
</rule>
<rule>
<name>Time of check time of use</name>
<key>STATIC_C_TOCTOU_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_TOCTOU_none</configKey>
<description><![CDATA[ A check occurs on a file's attributes before the file is used in a privileged operation, but things may have changed]]></description>
</rule>
<rule>
<name>User pointer dereference</name>
<key>STATIC_C_USER_POINTER_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_USER_POINTER_generic</configKey>
<description><![CDATA[ A user-land pointer is dereferenced without safety checks in the kernel]]></description>
</rule>
<rule>
<name>User pointer dereference</name>
<key>STATIC_C_USER_POINTER_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_USER_POINTER_none</configKey>
<description><![CDATA[ A user-land pointer is dereferenced without safety checks in the kernel]]></description>
</rule>
<rule>
<name>Missing assignment operator</name>
<key>STATIC_C_MISSING_ASSIGN_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_MISSING_ASSIGN_none</configKey>
<description><![CDATA[ Class that owns resources lacks a user-written assignment operator]]></description>
</rule>
<rule>
<name>Missing copy constructor</name>
<key>STATIC_C_MISSING_COPY_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_MISSING_COPY_none</configKey>
<description><![CDATA[ Class that owns resources lacks a user-written copy constructor]]></description>
</rule>
<rule>
<name>Unsafe assignment operator</name>
<key>STATIC_C_SELF_ASSIGN_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_SELF_ASSIGN_none</configKey>
<description><![CDATA[ Assignment operator does not check for self-assignment]]></description>
</rule>
<rule>
<name>Insufficient function coverage</name>
<key>STATIC_C_TA.INSUFFICIENT_COVERAGE_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_TA.INSUFFICIENT_COVERAGE_none</configKey>
<description><![CDATA[ Function does not reach coverage threshold required by the policy]]></description>
</rule>
<rule>
<name>Insufficient file coverage</name>
<key>STATIC_C_TA.INSUFFICIENT_FILE_COVERAGE_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_TA.INSUFFICIENT_FILE_COVERAGE_none</configKey>
<description><![CDATA[ File does not reach coverage threshold required by the policy]]></description>
</rule>
<rule>
<name>Test policy violation</name>
<key>STATIC_C_TA.*_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_TA.*_none</configKey>
<description><![CDATA[ Code does not satisfy the testing policy established by your organization.]]></description>
</rule>
<rule>
<name>Uncovered function</name>
<key>STATIC_C_TA.NO_COVERAGE_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_TA.NO_COVERAGE_none</configKey>
<description><![CDATA[ Function is not covered by any test]]></description>
</rule>
<rule>
<name>Uncalled function</name>
<key>STATIC_C_TA.UNCALLED_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_TA.UNCALLED_none</configKey>
<description><![CDATA[ Function is not called from any test]]></description>
</rule>
<rule>
<name>Uninitialized member</name>
<key>STATIC_C_UNINIT_CTOR_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_UNINIT_CTOR_generic</configKey>
<description><![CDATA[ A class member is not initialized by the constructor]]></description>
</rule>
<rule>
<name>Uninitialized pointer field</name>
<key>STATIC_C_UNINIT_CTOR_pointer</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_UNINIT_CTOR_pointer</configKey>
<description><![CDATA[ A pointer field is not initialized in the constructor]]></description>
</rule>
<rule>
<name>Uninitialized scalar field</name>
<key>STATIC_C_UNINIT_CTOR_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_UNINIT_CTOR_none</configKey>
<description><![CDATA[ A scalar field is not initialized by the constructor]]></description>
</rule>
<rule>
<name>Uninitialized scalar variable</name>
<key>STATIC_C_UNINIT_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_UNINIT_none</configKey>
<description><![CDATA[ Use of an uninitialized variable]]></description>
</rule>
<rule>
<name>Uninitialized value use</name>
<key>STATIC_C_UNINIT_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_UNINIT_generic</configKey>
<description><![CDATA[ Use of an uninitialized value]]></description>
</rule>
<rule>
<name>Missing/multiple returns</name>
<key>STATIC_C_MISSING_RETURN_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_MISSING_RETURN_generic</configKey>
<description><![CDATA[ Function that returns non-void is missing a return value or multiple return statements violate local coding standard]]></description>
</rule>
<rule>
<name>Missing return statement</name>
<key>STATIC_C_MISSING_RETURN_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_MISSING_RETURN_none</configKey>
<description><![CDATA[ Function that returns non-void is missing a return value]]></description>
</rule>
<rule>
<name>Modification of read-only buffer</name>
<key>STATIC_C_READONLY_BUFFER_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_READONLY_BUFFER_none</configKey>
<description><![CDATA[ Modification of read-only buffer]]></description>
</rule>
<rule>
<name>Same on both sides</name>
<key>STATIC_C_CONSTANT_EXPRESSION_RESULT_same_on_both_sides</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_same_on_both_sides</configKey>
<description><![CDATA[ The same expression occurs on both sides of an operator.]]></description>
</rule>
<rule>
<name>Ignoring number of bytes read</name>
<key>STATIC_C_CHECKED_RETURN_short_read</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CHECKED_RETURN_short_read</configKey>
<description><![CDATA[ Value returned from a function and indicating the number of bytes read is ignored.]]></description>
</rule>
<rule>
<name>Resource leak on an exceptional path</name>
<key>STATIC_C_RESOURCE_LEAK_exceptional_path</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_RESOURCE_LEAK_exceptional_path</configKey>
<description><![CDATA[ Leak of a system resource on an exception path (probably error handling)]]></description>
</rule>
<rule>
<name>Wrong size argument</name>
<key>STATIC_C_SIZEOF_MISMATCH_wrong_size_value</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_SIZEOF_MISMATCH_wrong_size_value</configKey>
<description><![CDATA[ The wrong size value is passed to a function]]></description>
</rule>
<rule>
<name>Managed pointer overwrite</name>
<key>STATIC_C_COM.ADDROF_LEAK_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_COM.ADDROF_LEAK_none</configKey>
<description><![CDATA[ A non-null pointer managed by a CComBSTR or CComPtr instance is passed by address to a function call. The value of the pointer can potentially be overwritten during the function call causing allocated memory to be leaked.]]></description>
</rule>
<rule>
<name>Division or modulo by zero</name>
<key>STATIC_C_DIVIDE_BY_ZERO_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_DIVIDE_BY_ZERO_generic</configKey>
<description><![CDATA[ Division or modulo by zero results in undefined behavior.]]></description>
</rule>
<rule>
<name>Division or modulo by zero</name>
<key>STATIC_C_DIVIDE_BY_ZERO_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_DIVIDE_BY_ZERO_none</configKey>
<description><![CDATA[ Division or modulo by zero results in undefined behavior.]]></description>
</rule>
<rule>
<name>Pointless string comparison</name>
<key>STATIC_C_CONSTANT_EXPRESSION_RESULT_pointless_string_compare</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_pointless_string_compare</configKey>
<description><![CDATA[ A string is compared against itself with strcmp or strncmp.]]></description>
</rule>
<rule>
<name>Truncated stdio return value</name>
<key>STATIC_C_CHAR_IO_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CHAR_IO_generic</configKey>
<description><![CDATA[ Stdio character-oriented I/O functions return int values such as EOF not representable by char variables]]></description>
</rule>
<rule>
<name>Truncated stdio return value</name>
<key>STATIC_C_CHAR_IO_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_CHAR_IO_none</configKey>
<description><![CDATA[ Stdio character-oriented I/O functions return int values such as EOF not representable by char variables]]></description>
</rule>
<rule>
<name>Assign does not return *this</name>
<key>STATIC_C_ASSIGN_NOT_RETURNING_STAR_THIS_indirect</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_ASSIGN_NOT_RETURNING_STAR_THIS_indirect</configKey>
<description><![CDATA[ A user-written assignment operator does not return a reference to *this]]></description>
</rule>
<rule>
<name>Assign does not return *this</name>
<key>STATIC_C_ASSIGN_NOT_RETURNING_STAR_THIS_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_ASSIGN_NOT_RETURNING_STAR_THIS_none</configKey>
<description><![CDATA[ A user-written assignment operator does not return a reference to *this]]></description>
</rule>
<rule>
<name>Assign does not return *this</name>
<key>STATIC_C_ASSIGN_NOT_RETURNING_STAR_THIS_usable_for_chained_assignment</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_ASSIGN_NOT_RETURNING_STAR_THIS_usable_for_chained_assignment</configKey>
<description><![CDATA[ A user-written assignment operator does not return a reference to *this]]></description>
</rule>
<rule>
<name>Deleting void pointer</name>
<key>STATIC_C_DELETE_VOID_generic</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_DELETE_VOID_generic</configKey>
<description><![CDATA[ Deleting a void pointer (void*)]]></description>
</rule>
<rule>
<name>Deleting void pointer</name>
<key>STATIC_C_DELETE_VOID_none</key>
<severity>BLOCKER</severity>
<configKey>STATIC_C_DELETE_VOID_none</configKey>
<description><![CDATA[ Deleting a void pointer (void*)]]></description>
</rule>
<rule>
<name>Misuse of enum</name>
<key>STATIC_C_ENUM_AS_BOOLEAN_generic</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_ENUM_AS_BOOLEAN_generic</configKey>
<description><![CDATA[ An enum-typed expression is used in a Boolean conditional context.  The enum type does not appear to have a distinguished false (zero) value]]></description>
</rule>
<rule>
<name>Misuse of enum</name>
<key>STATIC_C_ENUM_AS_BOOLEAN_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_ENUM_AS_BOOLEAN_none</configKey>
<description><![CDATA[ An enum-typed expression is used in a Boolean conditional context.  The enum type does not appear to have a distinguished false (zero) value]]></description>
</rule>
<rule>
<name>Failure to restore non-local value</name>
<key>STATIC_C_MISSING_RESTORE_likely</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISSING_RESTORE_likely</configKey>
<description><![CDATA[ Handles classes of flow where a function is either saving some external value, modifying the external value, and then clearly intending to restore it to its original state but failing to do so along one of many paths; or else is checking whether an external has some expected value, modifying the external value, then clearly intending to restore it to the expected value but failing to do so along a path.]]></description>
</rule>
<rule>
<name>Failure to restore non-local value</name>
<key>STATIC_C_MISSING_RESTORE_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISSING_RESTORE_none</configKey>
<description><![CDATA[ Handles classes of flow where a function is either saving some external value, modifying the external value, and then clearly intending to restore it to its original state but failing to do so along one of many paths; or else is checking whether an external has some expected value, modifying the external value, then clearly intending to restore it to the expected value but failing to do so along a path.]]></description>
</rule>
<rule>
<name>Possible failure to restore non-local value</name>
<key>STATIC_C_MISSING_RESTORE_possible</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_MISSING_RESTORE_possible</configKey>
<description><![CDATA[ Handles classes of flow where a function is either saving some external value, modifying the external value, and then possibly intending to restore it to its original state but not doing so along one of many paths; or else is checking whether an external has some expected value, modifying the external value, then possibly intending to restore it to the expected value but not doing so along a path.  Such code is only incorrect if the intent really was to restore along all paths.]]></description>
</rule>
<rule>
<name>Multiple return statements</name>
<key>STATIC_C_MISSING_RETURN_multiple_returns</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_MISSING_RETURN_multiple_returns</configKey>
<description><![CDATA[ Multiple return statements violates local coding standard]]></description>
</rule>
<rule>
<name>Mixing enum types</name>
<key>STATIC_C_MIXED_ENUMS_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MIXED_ENUMS_none</configKey>
<description><![CDATA[ An enum-typed expression is mixed with a different enum type]]></description>
</rule>
<rule>
<name>Big parameter passed by value</name>
<key>STATIC_C_PASS_BY_VALUE_generic</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_PASS_BY_VALUE_generic</configKey>
<description><![CDATA[ A large function call parameter or exception catch statement is passed by value]]></description>
</rule>
<rule>
<name>Big parameter passed by value</name>
<key>STATIC_C_PASS_BY_VALUE_none</key>
<severity>MAJOR</severity>
<configKey>STATIC_C_PASS_BY_VALUE_none</configKey>
<description><![CDATA[ A large function call parameter or exception catch statement is passed by value]]></description>
</rule>
<rule>
<name>Stray semicolon</name>
<key>STATIC_C_STRAY_SEMICOLON_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_STRAY_SEMICOLON_none</configKey>
<description><![CDATA[ A semicolon was erroneously inserted at a wrong point in the code, e.g. after an if, while, or for construct and before the block]]></description>
</rule>
<rule>
<name>Bad bit shift operation</name>
<key>STATIC_C_BAD_SHIFT_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_BAD_SHIFT_none</configKey>
<description><![CDATA[ A bit shift operation has a shift amount which is too large or has a negative value.]]></description>
</rule>
<rule>
<name>Missing comma in a string array initialization</name>
<key>STATIC_C_MISSING_COMMA_none</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_MISSING_COMMA_none</configKey>
<description><![CDATA[ A comma is suspiciously missing between lines in a string array initialization.]]></description>
</rule>
<rule>
<name>Division or modulo by float zero</name>
<key>STATIC_C_DIVIDE_BY_ZERO_float_divisor</key>
<severity>CRITICAL</severity>
<configKey>STATIC_C_DIVIDE_BY_ZERO_float_divisor</configKey>
<description><![CDATA[ An expression which may be zero is used as a divisor in floating-point arithmetic.]]></description>
</rule>
</rules>
